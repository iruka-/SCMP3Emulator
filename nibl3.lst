 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 1 - 2024年05月30日 15時32分15秒


    1/   0 :                            ; This listing was reverse engineered and commented from a dump of the 8073N ROM
    2/   0 :                            ; It may look like valid SC/MP-III assembler, but probably isn't. This is purely for
    3/   0 :                            ; reference - not for feeding into an assembler program.
    4/   0 :                            ; Analysed and commented by Holger Veit (20140315)
    5/   0 :                            		cpu 8070
    6/   0 :                            ; locations in on-chip RAM
    7/   0 : =0xFFC0                    MULOV	=	0xffc0					; DW high 16 bit from MPY
    8/   0 : =0xFFC2                    INPMOD	=	0xffc2					; DB input mode: 0x00 interactive, <>0 in INPUT, 01: running
    9/   0 : =0xFFC3                    CURRNT	= 	0xffc3					; DW current line number executed
   10/   0 : =0xFFC5                    RUNMOD	=	0xffc5					; DB runmode 'R', 0x00
   11/   0 : =0xFFC6                    EXTRAM	=	0xffc6					; DW start of variables (26 words)
   12/   0 : =0xFFC8                    AESTK	=	0xffc8					; DW start of arithmetic stack (13 words)
   13/   0 : =0xFFCA                    SBRSTK	=	0xffca					; DW start of GOSUB stack (10 words)
   14/   0 : =0xFFCC                    DOSTK	=	0xffcc					; DW start of DO stack (10 words)
   15/   0 : =0xFFCE                    FORSTK	=	0xffce					; DW start of FOR stack (28 words)
   16/   0 :                            
   17/   0 : =0xFFD0                    BUFAD	=	0xffd0					; DW
   18/   0 : =0xFFD2                    STACK	=	0xffd2					; DW top of stack
   19/   0 : =0xFFD4                    TXTBGN	=	0xffd4					; DW start of program area
   20/   0 : =0xFFD6                    TXTUNF	=	0xffd6					; DW
   21/   0 : =0xFFD8                    TXTEND	=	0xffd8					; DW end of program area
   22/   0 : =0xFFDA                    DOPTR	=	0xffda					; DW ptr to DO level?
   23/   0 : =0xFFDC                    FORPTR	=	0xffdc					; DW ptr to FOR level?
   24/   0 : =0xFFDE                    SBRPTR	= 	0xffde					; DW ptr to GOSUB level?
   25/   0 :                            
   26/   0 : =0xFFE0                    INTVEC	=	0xffe0					; DW current interrupt vector
   27/   0 : =0xFFE2                    INTAVC	=	0xffe2					; DW Interrupt A vector
   28/   0 : =0xFFE4                    INTBVC	=	0xffe4					; DW Interrupt B vector
   29/   0 : =0xFFE6                    BRKFLG	=	0xffe6					; DB if 0 check for BREAK from serial
   30/   0 : =0xFFE7                    NOINT	=	0xffe7					; DB flag to suppress INT after having set STAT
   31/   0 :                            
   32/   0 : =0xFFE8                    ONE		= 	0xffe8					; DW constant 1
   33/   0 : =0xFFEA                    ZERO	= 	0xffea					; DW constant 0
   34/   0 : =0xFFEC                    DLYTIM	=	0xffec					; DW delay value for serial I/O
   35/   0 : =0xFFEE                    CONTP	=	0xffee					; DW buffer pointer for CONT
   36/   0 :                            
   37/   0 : =0xFFF0                    TMPF0	=	0xfff0					; DW temporary for moving program code for insertion
   38/   0 : =0xFFF2                    TMPF2	=	0xfff2					; DW temp store for current program pointer
   39/   0 :                            
   40/   0 : =0xFFF4                    RNDNUM	=	0xfff4					; DW rnd number
   41/   0 :                            
   42/   0 : =0xFFF6                    TMPF6	=	0xfff6					; DB,DW temporary
   43/   0 : =0xFFF8                    UNUSE1	=	0xfff8					; DW unused
   44/   0 : =0xFFFB                    TMPFB	=	0xfffb					; DB,DW temporary
   45/   0 : =0xFFFC                    TMPFC	=	0xfffc					; DB,DW temporary (overlaps TMPFB)
   46/   0 : =0xFFFE                    TMPFE	=	0xfffe					; DW temporary, alias
   47/   0 :                            
   48/   0 :                            ; more constants
   49/   0 : =0x1000                    RAMBASE	=	0x1000					; start of RAM
   50/   0 : =0x1400                    ROMBASE	=	0x1400					; potential start of a ROM (BASIC AREA)
   51/   0 : =0xFD00                    BAUDFLG	=	0xFD00					; address of baudrate selection bits
   52/   0 :                            
   53/   0 : =0x8                       BS		=	0x08					; back space
   54/   0 : =0xD                       CR		=	0x0d					; carriage return
   55/   0 : =0xA                       LF		=	0x0a					; line feed
   56/   0 : =0x15                      NAK		=	0x15					; CTRL-U, NAK
   57/   0 : =' '                       SPACE	=	' '						; space character
   58/   0 : ='>'                       GTR		=	'>'						; prompt for interactive mode
   59/   0 : ='?'                       QUEST	=	'?'						; prompt for input mode
   60/   0 : ='^'                       CARET	=	'^'						; prefix for CTRL output
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 2 - 2024年05月30日 15時32分15秒


   61/   0 :                            
   62/   0 :                            
   63/   0 :                            ; interpreter starts here
   64/   0 :                            ; assumptions "should be" refer to 1K RAM at 0x1000-0x13ff)
   65/   0 :                            			ORG	0
   66/   0 : 00                         			NOP    					; lost byte because of PC preincrement
   67/   1 : 24 09 00                   			JMP 	COLD			; Jump to cold start
   68/   4 : 24 C2 08                   			JMP		INTA			; Jump to interrupt a handler
   69/   7 : 24 C7 08                   			JMP 	INTB			; Jump to interrupt b handler
   70/   A : 84 00 14                   COLD:		LD		EA, =ROMBASE	; bottom address of ROM
   71/   D : 8D D4                      COLD1:		ST		EA, TXTBGN		; set begin of text to ROM
   72/   F : 84 00 10                   			LD		EA, =RAMBASE	; set P2 to point to base of RAM
   73/  12 : 46                         			LD 		P2, EA			;
   74/  13 : 20 75 00                   COLD2:		JSR 	TSTRAM1			; test for RAM at loc P2
   75/  16 : 7C FB                      			BNZ 	COLD2			; not zero: no RAM, loop
   76/  18 : 32                         			LD 		EA, P2			; found RAM, get address
   77/  19 : BC 01 00                   			SUB 	EA, =1			; subtract 1 to get the current position
   78/  1C : 7C F5                      			BNZ 	COLD2			; is not at xx00, search next
   79/  1E : 74 20                      			BRA 	COLD3			; found a page skip over call tbl, continue below
   80/  20 :                            
   81/  20 :                            ; short CALL table
   82/  20 : 44 06                      			DW		RELEXP-1			; call 0 (RELEXP)
   83/  22 : F7 06                      			DW		FACTOR-1  		; call 1 (FACTOR)
   84/  24 : 4F 08                      			DW		SAVOP-1    		; call 2 (SAVOP)
   85/  26 : 82 06                      			DW		COMPAR-1		; call 3 (COMPAR)
   86/  28 : 42 08                      			DW		APUSH-1			; call 4 (APUSH)
   87/  2A : 52 08                      			DW		APULL-1			; call 5 (APULL)
   88/  2C : 0B 02                      			DW		ENDCMD-1		; call 6 (ENDCMD)
   89/  2E : 90 09                      			DW		PUTC-1			; call 7 (PUTC)
   90/  30 : 8B 09                      			DW		CRLF-1			; call 8 (CRLF)
   91/  32 : 55 05                      			DW		GETCHR-1		; call 9 (GETCHR)
   92/  34 : 0A 08                      			DW		NEGATE-1		; call 10 (NEGATE)
   93/  36 : 1C 06                      			DW		CMPTOK-1		; call 11 (CMPTOK)
   94/  38 : 66 05                      			DW		EXPECT-1		; call 12 (EXPECT c, offset)
   95/  3A : 9D 05                      			DW		NUMBER-1		; call 13 (NUMBER, offset)
   96/  3C : 47 05                      			DW		PRTLN-1			; call 14 (PRTLN)
   97/  3E : D5 08                      			DW		ERROR-1			; call 15 (ERROR)
   98/  40 :                            
   99/  40 :                            ; continues here from cold start
  100/  40 : 8D C6                      COLD3:		ST		EA, EXTRAM		; arrive here with xx00, store it (should be 0x1000)
  101/  42 : B4 00 01                   			ADD		EA, =0x0100		; add 256
  102/  45 : 8D D2                      			ST		EA, STACK		; store as STACK address (should be 0x1100)
  103/  47 : 45                         			LD		SP, EA    		; initialize stack pointer
  104/  48 : 20 75 00                   COLD4:		JSR 	TSTRAM1			; check RAM at current pos P2 (should be 0x1000)
  105/  4B : 6C FB                      			BZ		COLD4			; advance until no longer RAM
  106/  4D :                            									; P2 points to last RAM+2
  107/  4D : C6 FE                      			LD		A, @-2, P2		; subtract 2 from P2
  108/  4F : 32                         			LD		EA, P2    		; get last RAM address
  109/  50 : 8D D8                      			ST		EA, TXTEND		; store at end of text (should be 0x13ff)
  110/  52 : 85 D4                      			LD		EA, TXTBGN		; load begin of ROM text (0x8000)
  111/  54 : 46                         			LD		P2, EA    		; put into P2
  112/  55 : 20 75 00                   			JSR 	TSTRAM1			; is there RAM?
  113/  58 : 6C 03                      			BZ		COLD5			; yes, skip
  114/  5A : 24 E2 01                   			JMP		RUN				; no, this could be a ROM program, run it
  115/  5D : 85 D2                      COLD5:		LD		EA, STACK		; get stack top
  116/  5F : BD D4                      			SUB		EA, TXTBGN		; subtract begin of program
  117/  61 : 06                         			LD		A, S   			; get carry bit
  118/  62 : 64 04                      			BP		COLD6			; not set, skip
  119/  64 : 85 D2                      			LD		EA, STACK		; get stack top
  120/  66 : 8D D4                      			ST 		EA, TXTBGN		; make it new TXTBGN
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 3 - 2024年05月30日 15時32分15秒


  121/  68 : C5 C5                      COLD6:		LD 		A, RUNMOD  		; get mode
  122/  6A : E4 52                      			XOR 	A, ='R'			; is it 'R'?
  123/  6C : 6C 35                      			BZ		MAINLP			; yes, skip
  124/  6E : 20 C9 05                   			JSR		INITAL			; intialize all interpreter variables
  125/  71 : 74 27                      			BRA		MAIN			; continue
  126/  73 :                            
  127/  73 :                            ENDRAM1:
  128/  73 : C4 FF                      			LD		A, =0xff		; if P2>=0x8000 then return NonZero(RAM END)
  129/  75 : 5C                         			RET
  130/  76 :                            TSTRAM1:
  131/  76 : 32                         			LD		EA,P2
  132/  77 : 40                         			LD		A,E
  133/  78 : FC 80                      			SUB		A, =0x80
  134/  7A : 64 F7                      			BP		ENDRAM1
  135/  7C :                            
  136/  7C :                            	; check RAM at loc P2; return 0 if found, nonzero if no RAM
  137/  7C : C6 01                      TSTRAM:		LD		A, @1, P2		; get value from RAM, autoincrement
  138/  7E : 48                         			LD		E, A    		; save old value into E (e.g. 0x55)
  139/  7F : E4 FF                      			XOR		A, =0xff			; complement value (e.g. 0xAA)
  140/  81 : CA FF                      			ST		A, -1, P2    	; store it back (0xAA)
  141/  83 : E2 FF                      			XOR		A, -1, P2		; read back and compare (should be 0x00)
  142/  85 : 01                         			XCH		A, E    		; A=old value, E=0x00 (if RAM)
  143/  86 : CA FF                      			ST		A, -1, P2    	; store back old value
  144/  88 : E2 FF                      			XOR		A, -1, P2		; read back and compare (should be 0x00)
  145/  8A : 58                         			OR		A, E   			; or both tests, should be 0x00 if RAM)
  146/  8B : 5C                         			RET						; return zero, if RAM, nonzero if none
  147/  8C :                            
  148/  8C :                            ; NEW command
  149/  8C : 20 C9 05                   NEW:		JSR		INITAL			; initialize interpreter variables
  150/  8F : C2 00                      			LD		A, 0, P2		; get a char from current program position (initially ROMBASE)
  151/  91 : E4 0D                      			XOR		A, =CR			; is char a CR?
  152/  93 : 6C 05                      			BZ		MAIN			; yes, skip to program
  153/  95 : 10                         			CALL	0
  154/  96 : 15                         			CALL	5    			; APULL
  155/  97 : 24 0C 00                   			JMP		COLD1    		; back to cold start
  156/  9A :                            
  157/  9A : 85 D4                      MAIN: 		LD		EA, TXTBGN		; get start of program area
  158/  9C : 8D D6                      			ST		EA, TXTUNF		; store as end of program
  159/  9E : 46                         			LD		P2, EA			; point P2 to it
  160/  9F : C4 7F                      			LD		A, =0x7f    		; set end of program flag
  161/  A1 : CA 00                      			ST		A, 0, P2    	; at that position
  162/  A3 :                            
  163/  A3 :                            ; main interpreter loop
  164/  A3 : 85 D2                      MAINLP:		LD		EA, STACK		; reinitialize stack
  165/  A5 : 45                         			LD		SP, EA    
  166/  A6 : 85 C6                      			LD		EA, EXTRAM		; start of RAM		
  167/  A8 : B4 34 00                   			ADD		EA, =52			; offset to AESTK    
  168/  AB : 8D C8                      			ST		EA, AESTK		; set position of arithmetic stack
  169/  AD : 47                         			LD		P3, EA			; P3 is arith stack pointer
  170/  AE : 20 F6 09                   			JSR		INITBD			; initialize baud rate
  171/  B1 : 18                         			CALL 	8				; CRLF
  172/  B2 : C5 C2                      			LD		A, INPMOD		; mode flag?
  173/  B4 : 6C 0C                      			BZ 		MAINL2			; zero, skip
  174/  B6 :                            									; no, this is a break CTRL-C
  175/  B6 : 32                         			LD		EA, P2			; current pointion of buffer
  176/  B7 : 8D EE                      			ST		EA, CONTP		; save position (for CONT)
  177/  B9 : 22 1A 09                   			PLI		P2, =STOPMSG	; STOP message
  178/  BC : 1E                         			CALL	14				; PRTLN
  179/  BD : 5E                         			POP		P2				; restore P2
  180/  BE : 20 0A 09                   			JSR		PRTAT			; print AT line#
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 4 - 2024年05月30日 15時32分15秒


  181/  C1 : 18                         MAINL1:		CALL	8				; CRLF
  182/  C2 : 85 C8                      MAINL2:		LD 		EA, AESTK		; initialize P3 with AESTK
  183/  C4 : 47                         			LD		P3, EA    
  184/  C5 : 84 00 00                   			LD		EA, =0			; initialize constant ZERO
  185/  C8 : 8D EA                      			ST		EA, ZERO		
  186/  CA : CD C2                      			ST		A, INPMOD   	; set cmd mode=0
  187/  CC : C4 01                      			LD		A, =1			; initialize constant ONE
  188/  CE : 8D E8                      			ST		EA, ONE			
  189/  D0 : 20 55 08                   			JSR		GETLN			; read a line into buffer
  190/  D3 : 19                         			CALL	9				; GETCHR
  191/  D4 : 1D                         			CALL 	13				; NUMBER
  192/  D5 : 85                         			DB		0x85  			; not a number, skip to DIRECT
  193/  D6 : 85 D4                      			LD		EA, TXTBGN		; start of program
  194/  D8 : BD E8                      			SUB		EA, ONE    		; minus 1
  195/  DA : BD D6                      			SUB		EA, TXTUNF		; subtract end of program
  196/  DC : 06                         			LD		A, S    		; get status
  197/  DD : 64 02                      			BP		MAINL3   			; overflow? no, skip
  198/  DF : 1F                         			CALL	15				; ERROR
  199/  E0 : 01                         			DB 		1				; 1 (out of mem)
  200/  E1 : 32                         MAINL3:		LD		EA, P2    		; get buffer pointer
  201/  E2 : 8D F0                      			ST		EA, TMPF0		; save it
  202/  E4 : 20 76 01                   			JSR		FINDLN			; find line in program
  203/  E7 : 7C 1B                      			BNZ		MAINL4			; no match, skip
  204/  E9 : 56                         			PUSH	P2				; save p2 (line begin)
  205/  EA : 20 9A 01                   			JSR		TOEOLN			; advance to end of line
  206/  ED : 81 00                      			LD		EA, 0, SP		; get line begin (P2)
  207/  EF : 47                         			LD		P3, EA			; into P3
  208/  F0 : 32                         			LD		EA, P2			; get end of line from TOEOLN
  209/  F1 : 1A                         			CALL	10    			; NEGATE
  210/  F2 : 08                         			PUSH	EA				; save -endline
  211/  F3 : B5 E8                      			ADD		EA, ONE			; add one (for CR)
  212/  F5 : B5 D6                      			ADD		EA, TXTUNF		; add end of program area
  213/  F7 : 8D FE                      			ST		EA, TMPFE		; store number of bytes to move
  214/  F9 : 3A                         			POP		EA				; restore -endline
  215/  FA : B1 00                      			ADD		EA, 0, SP		; subtract from start to get number of bytes to move
  216/  FC : B5 D6                      			ADD		EA, TXTUNF		; add end of program area
  217/  FE : 8D D6                      			ST		EA, TXTUNF		; set a new end of program
  218/ 100 : 20 65 01                   			JSR		BMOVE			; move area
  219/ 103 : 5E                         			POP		P2				; restore start of line
  220/ 104 :                            ; replace or add line
  221/ 104 : 32                         MAINL4:		LD		EA, P2			; copy into P3
  222/ 105 : 47                         			LD		P3, EA    
  223/ 106 : 85 F0                      			LD		EA, TMPF0		; buffer pointer
  224/ 108 : 46                         			LD		P2, EA			; into P2
  225/ 109 : 19                         			CALL	9				; GETCHR
  226/ 10A : E4 0D                      			XOR		A, =CR			; is it a single line number?
  227/ 10C : 6C B4                      			BZ		MAINL2			; yes, ignore that
  228/ 10E : 85 D0                      			LD		EA, BUFAD		; address of buffer
  229/ 110 : 46                         			LD		P2, EA			; into P2
  230/ 111 : 19                         			CALL	9				; GETCHR
  231/ 112 : 32                         			LD		EA, P2			; save buffer pointer
  232/ 113 : 8D F6                      			ST		EA, TMPF6
  233/ 115 : 20 9A 01                   			JSR		TOEOLN			; advance to end of line
  234/ 118 : 32                         			LD		EA, P2			; get end of line
  235/ 119 : BD F6                      			SUB		EA, TMPF6		; subtract to get length of buffer
  236/ 11B : 8D FE                      			ST		EA, TMPFE		; store number of bytes to move
  237/ 11D : B5 D6                      			ADD		EA, TXTUNF		; add temporary end of buffer
  238/ 11F : BD D8                      			SUB		EA, TXTEND		; store as new end of program
  239/ 121 : BD E8                      			SUB		EA, ONE			; subtract one
  240/ 123 : 01                         			XCH		A, E			; is result negative?
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 5 - 2024年05月30日 15時32分15秒


  241/ 124 : 64 3E                      			BP		OMERR			; out of memory error
  242/ 126 : 57                         			PUSH	P3				; save P3
  243/ 127 : 85 D6                      			LD		EA, TXTUNF		; get tmp area
  244/ 129 : 46                         			LD		P2, EA			; into P2
  245/ 12A : 33                         			LD		EA, P3			; line to insert
  246/ 12B : BD D6                      			SUB		EA, TXTUNF		; subtract tmp buf
  247/ 12D : 1A                         			CALL	10				; NEGATE
  248/ 12E : 8D FB                      			ST		EA, TMPFB		; number of bytes to expand
  249/ 130 : 58                         			OR		A, E			; is result zero?
  250/ 131 : 0A                         			PUSH	A    			; save it for later check
  251/ 132 : 85 D6                      			LD		EA, TXTUNF		; tmp buf
  252/ 134 : B5 FE                      			ADD		EA, TMPFE		; add length of line
  253/ 136 : 8D D6                      			ST		EA, TXTUNF		; store
  254/ 138 : 47                         			LD		P3, EA			; into P3
  255/ 139 : C2 00                      			LD		A, 0, P2		; copy a byte
  256/ 13B : CB 00                      			ST		A, 0, P3
  257/ 13D : 38                         			POP		A				; restore result from above (sets Z flag)
  258/ 13E : 6C 10                      			BZ		MAINL6			; was zero, skip
  259/ 140 : C6 FF                      MAINL5:		LD		A, @-1, P2		; otherwise copy backwards TMPFB bytes
  260/ 142 : CF FF                      			ST		A, @-1, P3
  261/ 144 : 9D FB                      			DLD		A, TMPFB		; decrement byte counter
  262/ 146 : 7C F8                      			BNZ		MAINL5
  263/ 148 : C5 FC                      			LD		A, TMPFB+1
  264/ 14A : 6C 04                      			BZ		MAINL6			; exit loop if zero
  265/ 14C : 9D FC                      			DLD		A, TMPFB+1
  266/ 14E : 74 F0                      			BRA		MAINL5			; loop
  267/ 150 : 5F                         MAINL6:		POP		P3				; restore target location
  268/ 151 : 85 F6                      			LD		EA, TMPF6		
  269/ 153 : 46                         			LD		P2, EA			; restore source location
  270/ 154 : 20 65 01                   			JSR		BMOVE			; move new line into program
  271/ 157 : 24 C1 00                   MAINL7:		JMP		MAINL2			; done, continue in main loop
  272/ 15A :                            
  273/ 15A :                            ; parse a direct command
  274/ 15A : C2 00                      DIRECT:		LD		A, 0, P2		; get char from buffer
  275/ 15C : E4 0D                      			XOR		A, =CR			; is it a CR?
  276/ 15E : 6C F7                      			BZ		MAINL7			; yes, continue in main loop
  277/ 160 : 23 A1 01                   			PLI		P3, =CMDTB1		; load first CMD table
  278/ 163 : 1B                         			CALL	11				; CMPTOK
  279/ 164 :                            
  280/ 164 :                            ; out of memory error
  281/ 164 : 1F                         OMERR:		CALL	15				; ERROR
  282/ 165 : 01                         			DB		1				; 1 (out of memory)
  283/ 166 :                            ;--------------------------------------------------------------------------------------------------
  284/ 166 :                            
  285/ 166 :                            ; move TMPFE bytes ascending from @P2 to @P3
  286/ 166 : C6 01                      BMOVE:		LD		A, @1, P2		; get char from first pos
  287/ 168 : CF 01                      			ST		A, @1, P3		; store into second
  288/ 16A : 9D FE                      			DLD		A, TMPFE    	; decrement byte counter 16 bit
  289/ 16C : 7C F8                      			BNZ		BMOVE
  290/ 16E : C5 FF                      			LD		A, TMPFE+1
  291/ 170 : 6C 04                      			BZ		BMOVE1   		; exit if zero
  292/ 172 : 9D FF                      			DLD		A, TMPFE+1
  293/ 174 : 74 F0                      			BRA		BMOVE			; loop
  294/ 176 : 5C                         BMOVE1:		RET
  295/ 177 :                            ;--------------------------------------------------------------------------------------------------
  296/ 177 :                            ; find line in program, 0 = found, 1 = insert before, -1 = not found, line in P2
  297/ 177 :                            ; line number to find is on AESTK
  298/ 177 : 85 D4                      FINDLN:		LD 		EA, TXTBGN		; get start of program
  299/ 179 : 46                         			LD 		P2, EA    		; into P2
  300/ 17A : 32                         FINDL1:		LD		EA, P2			; get P2
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 6 - 2024年05月30日 15時32分15秒


  301/ 17B : 8D FB                      			ST		EA, TMPFB		; save temporary
  302/ 17D : 19                         			CALL	9				; GETCHR
  303/ 17E : 1D                         			CALL	13				; NUMBER
  304/ 17F : 18                         			DB 		0x18			; skip if not number to FINDL4
  305/ 180 : 15                         			CALL 	5				; APULL
  306/ 181 : BB FE                      			SUB 	EA, -2, P3		; subtract number from the one on stack (the line number found)
  307/ 183 : 01                         			XCH		A, E			; is larger?
  308/ 184 : 64 05                      			BP		FINDL2			; yes skip
  309/ 186 : 20 9A 01                   			JSR		TOEOLN			; advance to end of line
  310/ 189 : 74 EF                      			BRA		FINDL1			; loop
  311/ 18B : 58                         FINDL2:		OR		A, E
  312/ 18C : 6C 02                      			BZ		FINDL3			; is exactly the same?
  313/ 18E : C4 01                      			LD		A, =01			; no, return 1
  314/ 190 : 0A                         FINDL3:		PUSH	A
  315/ 191 : 15                         			CALL	5				; APULL
  316/ 192 : 85 FB                      			LD		EA, TMPFB		; get start of this line
  317/ 194 : 46                         			LD		P2, EA    		; into P2
  318/ 195 : 38                         			POP		A				; restore result
  319/ 196 : 5C                         			RET						; return with 0, if exact match, 1 if insert
  320/ 197 : C4 FF                      FINDL4:		LD		A, =0xff		; return with -1: end of program
  321/ 199 : 74 F5                      			BRA		FINDL3		
  322/ 19B :                            
  323/ 19B :                            ;--------------------------------------------------------------------------------------------------
  324/ 19B :                            ; advance to end of line
  325/ 19B : C4 0D                      TOEOLN:		LD		A, =CR			; search for end of line
  326/ 19D : 2E                         			SSM 	P2				; should be within next 256 bytes
  327/ 19E : 74 17                      			BRA		UCERR			; didn't find one, error 3
  328/ 1A0 : 5C                         			RET						; found one, return with P2 pointing to char after CR
  329/ 1A1 :                            
  330/ 1A1 :                            ;--------------------------------------------------------------------------------------------------
  331/ 1A1 :                            ; set of DIRECT commands
  332/ 1A1 : 4C 49 53 54                CMDTB1:		DB 		'LIST'
  333/ 1A5 : 93                         			DB 		0x93			; to LIST
  334/ 1A6 : 4E 45 57                   			DB 		'NEW'
  335/ 1A9 : 8A                         			DB 		0x8a			; to NEW2
  336/ 1AA : 52 55 4E                   			DB 		'RUN'
  337/ 1AD : B5                         			DB 		0xb5			; to RUN
  338/ 1AE : 43 4F 4E 54                			DB 		'CONT'
  339/ 1B2 : A7                         			DB 		0xa7			; to CONT
  340/ 1B3 : D2                         			DB		0xd2			; default case to EXEC1
  341/ 1B4 :                            
  342/ 1B4 :                            ;--------------------------------------------------------------------------------------------------
  343/ 1B4 :                            ; NEW command
  344/ 1B4 : 24 8B 00                   NEW2:		JMP		NEW				; do new command
  345/ 1B7 :                            
  346/ 1B7 :                            ;--------------------------------------------------------------------------------------------------
  347/ 1B7 : 1F                         UCERR:		CALL 	15				; ERROR
  348/ 1B8 : 03                         			DB 		3				; 3 (unexpected char)
  349/ 1B9 :                            
  350/ 1B9 :                            ;--------------------------------------------------------------------------------------------------
  351/ 1B9 :                            ; LIST command
  352/ 1B9 : 1D                         LIST:		CALL	13				; NUMBER
  353/ 1BA : 03                         			DB		3				; if no number, skip to LIST0
  354/ 1BB : 74 03                      			BRA		LIST1
  355/ 1BD : 85 EA                      LIST0:		LD		EA, ZERO		; no number given, start with line 0
  356/ 1BF : 14                         			CALL	4				; APUSH put on stack
  357/ 1C0 : 20 76 01                   LIST1:		JSR		FINDLN			; find line in program, or next one
  358/ 1C3 : 19                         LIST2:		CALL	9 		  		; GETCHR from location found
  359/ 1C4 : 56                         			PUSH	P2    
  360/ 1C5 : 1D                         			CALL	13				; NUMBER 
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 7 - 2024年05月30日 15時32分15秒


  361/ 1C6 : 0A                         			DB		0x0a			; if error, goto LIST3
  362/ 1C7 : 15                         			CALL	5				; APULL
  363/ 1C8 : 5E                         			POP		P2    
  364/ 1C9 : 1E                         			CALL	14				; PRTLN
  365/ 1CA : 18                         			CALL	8				; CRLF
  366/ 1CB : 20 26 09                   			JSR		CHKBRK			; test break
  367/ 1CE : 74 F3                      			BRA		LIST2
  368/ 1D0 : 5E                         LIST3:		POP		P2
  369/ 1D1 : 24 A2 00                   MAIN1:		JMP		MAINLP
  370/ 1D4 :                            
  371/ 1D4 :                            ;--------------------------------------------------------------------------------------------------
  372/ 1D4 : 54 48 45 4E                CMDTB6:		DB		'THEN'			; then table
  373/ 1D8 : AD                         			DB		0xad			; to EXEC1
  374/ 1D9 : AC                         			DB		0xac			; default case to EXEC1
  375/ 1DA :                            
  376/ 1DA :                            ;--------------------------------------------------------------------------------------------------
  377/ 1DA :                            ; CONT command
  378/ 1DA : 85 EE                      CONT:		LD		EA, CONTP		; restore program pointer from CONT
  379/ 1DC : 46                         			LD		P2, EA
  380/ 1DD : C4 01                      			LD		A, =01			; set program mode
  381/ 1DF : CD C2                      			ST		A, INPMOD
  382/ 1E1 : 74 37                      			BRA		ENDCM1
  383/ 1E3 :                            
  384/ 1E3 :                            ;--------------------------------------------------------------------------------------------------
  385/ 1E3 :                            ; RUN command
  386/ 1E3 : 20 C9 05                   RUN:		JSR		INITAL			; initialize interpreter variables
  387/ 1E6 : C4 01                      			LD		A, =01			; set "running mode"
  388/ 1E8 : CD C2                      			ST		A, INPMOD
  389/ 1EA : 85 D4                      			LD		EA, TXTBGN		; start at first line
  390/ 1EC : 46                         			LD		P2, EA			; in buffer
  391/ 1ED : 74 04                      			BRA		RUN2			; skip
  392/ 1EF : C5 C2                      RUN1:		LD		A, INPMOD
  393/ 1F1 : 6C DE                      			BZ		MAIN1
  394/ 1F3 : 85 EA                      RUN2:		LD		EA, ZERO		; load 0
  395/ 1F5 : 14                         			CALL	4				; APUSH
  396/ 1F6 :                            
  397/ 1F6 : 20 79 01                   RUN3:		JSR		FINDL1			; find line from current position
  398/ 1F9 : 64 06                      			BP		RUN4			; found one
  399/ 1FB : C4 00                      			LD		A, =00			; set 'not running'
  400/ 1FD : CD C2                      			ST		A, INPMOD
  401/ 1FF : 74 D0                      			BRA		MAIN1			; back to mainloop
  402/ 201 : 1D                         RUN4:		CALL	13				; parse line NUMBER
  403/ 202 : 08                         			DB		 8				; not found: syntax error, goto SNERR1
  404/ 203 : 15                         			CALL	 5				; APULL line number
  405/ 204 : 8D C3                      			ST		EA, CURRNT		; set as current line
  406/ 206 :                            
  407/ 206 :                            
  408/ 206 : 23 37 02                   EXEC1:		PLI		P3, =CMDTB2		; run loop
  409/ 209 : 1B                         			CALL	11				; process commands
  410/ 20A :                            
  411/ 20A : 1F                         SNERR1:		CALL	15				; ERROR
  412/ 20B : 04                         			DB 		4				; 4 (syntax error)
  413/ 20C :                            
  414/ 20C :                            ;--------------------------------------------------------------------------------------------------
  415/ 20C :                            ; handle end of CMD, check for break or interrupts... (call 6)
  416/ 20C : 3A                         ENDCMD:		POP		EA				; drop return address
  417/ 20D : C5 E7                      			LD		A, 0xffe7		; flag set?
  418/ 20F : 7C 09                      			BNZ		ENDCM1			; yes, skip
  419/ 211 : C5 C2                      			LD		A, INPMOD		; interactive mode?
  420/ 213 : 6C 05                      			BZ		ENDCM1			; yes skip
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 8 - 2024年05月30日 15時32分15秒


  421/ 215 : 85 E0                      			LD		EA, INTVEC		; interrupt pending?
  422/ 217 : 58                         			OR		A, E
  423/ 218 : 7C 14                      			BNZ		ENDCM3			; yes, skip
  424/ 21A :                            
  425/ 21A : C4 00                      ENDCM1:		LD		A, =0			
  426/ 21C : CD E7                      			ST		A, NOINT
  427/ 21E : 20 26 09                   			JSR		CHKBRK			; check for break
  428/ 221 : 1C                         			CALL	12				; EXPECT
  429/ 222 : 3A                         			DB		':'				; colon?
  430/ 223 : 03                         			DB		0x03			; no, to ENDCM2
  431/ 224 : 74 E0                      			BRA		EXEC1			; continue run loop
  432/ 226 : C6 01                      ENDCM2:		LD		A, @1, P2		; advance to next char
  433/ 228 : E4 0D                      			XOR		A, =CR			; is it end of line?
  434/ 22A : 7C 8B                      			BNZ		UCERR			; error unexpected char
  435/ 22C : 74 C1                      			BRA		RUN1			; continue
  436/ 22E :                            
  437/ 22E : 85 E0                      ENDCM3:		LD		EA, INTVEC		; get pending int vector
  438/ 230 : 14                         			CALL	4				; APUSH
  439/ 231 : 85 EA                      			LD		EA, ZERO		; 
  440/ 233 : 8D E0                      			ST		EA, INTVEC		; clear pending int
  441/ 235 : 74 49                      			BRA		GOSUB1			; jump into GOSUB (process interrupt)
  442/ 237 :                            
  443/ 237 : 4C 45 54                   CMDTB2:		DB		'LET'
  444/ 23A : A6                         			DB 		0xa6			; to LET
  445/ 23B : 49 46                      			DB		'IF'
  446/ 23D : F3                         			DB		0xf3			; to IFCMD
  447/ 23E : 4C 49 4E 4B                			DB		'LINK'
  448/ 242 : F7                         			DB		0xf7			; to LINK
  449/ 243 : 4E 45 58 54                			DB		'NEXT'
  450/ 247 : 9C                         			DB		0x9c			; to NEXT
  451/ 248 : 55 4E 54 49 4C             			DB		'UNTIL'
  452/ 24D : DB                         			DB		0xdb			; to UNTIL
  453/ 24E : 47 4F                      			DB		'GO'
  454/ 250 : 96                         			DB		0x96			; to GOCMD
  455/ 251 : 52 45 54 55 52 4E          			DB		'RETURN'
  456/ 257 : BD                         			DB		0xbd			; to RETURN
  457/ 258 : 52 45 4D                   			DB		'REM'
  458/ 25B : CF                         			DB		0xcf			; to REMCMD
  459/ 25C : 80                         			DB		0x80			; default case to EXEC2
  460/ 25D :                            
  461/ 25D : 23 C8 02                   EXEC2:		PLI		P3, =CMDTB7		; load table 7
  462/ 260 : 1B                         			CALL	11    			; CMPTOK
  463/ 261 :                            
  464/ 261 :                            ;------------------------------------------------------------------------------
  465/ 261 :                            ; forward to assignment
  466/ 261 : 24 63 04                   LET:		JMP		ASSIGN			; ignore LET and continue with general assigment
  467/ 264 :                            
  468/ 264 :                            ;------------------------------------------------------------------------------
  469/ 264 :                            ; forward to NEXT cmd
  470/ 264 : 24 71 03                   NEXT:		JMP		NEXT0			; handle NEXT
  471/ 267 :                            
  472/ 267 :                            ;------------------------------------------------------------------------------
  473/ 267 :                            ; handle GOTO or GOSUB
  474/ 267 : 23 6B 02                   GOCMD:  	PLI		P3, =CMDTB5  	; check for TO or SUB
  475/ 26A : 1B                         			CALL	11
  476/ 26B :                            
  477/ 26B : 54 4F                      CMDTB5:		DB		'TO'
  478/ 26D : 85                         			DB		0x85			; to GOTO
  479/ 26E : 53 55 42                   			DB		'SUB'
  480/ 271 : 8D                         			DB		0x8d
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 9 - 2024年05月30日 15時32分15秒


  481/ 272 : 80                         			DB		0x80			; default case to GOTO
  482/ 273 :                            
  483/ 273 :                            ;------------------------------------------------------------------------------
  484/ 273 :                            ; GOTO command
  485/ 273 : 10                         GOTO:		CALL	0				; RELEXP
  486/ 274 : C4 01                      GOTO1:		LD		A, =1			;
  487/ 276 : CD C2                      			ST		A, INPMOD		; set 'running mode'
  488/ 278 : 20 76 01                   			JSR		FINDLN			; find line in buffer
  489/ 27B : 6C 84                      			BZ		RUN4			; skip to line number check
  490/ 27D : 1F                         			CALL	15				; error    
  491/ 27E : 07                         			DB		7				; 7 (goto target does not exist)    
  492/ 27F :                            
  493/ 27F :                            ;------------------------------------------------------------------------------
  494/ 27F :                            ; GOSUB command
  495/ 27F : 10                         GOSUB:		CALL	0				; RELEXP 
  496/ 280 : 85 DE                      GOSUB1:		LD		EA, SBRPTR		; get SBR stack pointer
  497/ 282 : 57                         			PUSH	P3				; save P3
  498/ 283 : 47                         			LD		P3, EA			; SBR stack in P3
  499/ 284 : 85 CC                      			LD		EA, DOSTK		; mark do stack pointer
  500/ 286 : CD F6                      			ST		A, TMPF6		; in temporary
  501/ 288 : 33                         			LD		EA, P3			; get SBR stack ptr
  502/ 289 : 20 C9 03                   			JSR		CHKSBR			; check for overflow			
  503/ 28C : 32                         			LD		EA, P2			; get buffer pointer
  504/ 28D : 8F 02                      			ST		EA, @2, P3		; 
  505/ 28F : 33                         			LD		EA, P3			; save new SBR pointer
  506/ 290 : 8D DE                      			ST		EA, SBRPTR
  507/ 292 : 5F                         			POP		P3				; restore P3
  508/ 293 : 74 DF                      			BRA		GOTO1			; do GOTO
  509/ 295 :                            
  510/ 295 :                            ;------------------------------------------------------------------------------
  511/ 295 :                            ; RETURN command
  512/ 295 : 85 DE                      RETURN:		LD		EA, SBRPTR		; get SBR ptr
  513/ 297 : BD CA                      			SUB		EA, SBRSTK		; is stack empty?
  514/ 299 : 6C 0C                      			BZ		RETERR			; yes error 8
  515/ 29B : 85 DE                      			LD		EA, SBRPTR		; decrement SBR ptr
  516/ 29D : BC 02 00                   			SUB		EA, =2
  517/ 2A0 : 8D DE                      			ST		EA, SBRPTR		; store it back
  518/ 2A2 : 46                         			LD		P2, EA			; into P2
  519/ 2A3 : 82 00                      			LD		EA, 0, P2		; restore buffer pointer
  520/ 2A5 : 46                         			LD		P2, EA
  521/ 2A6 : 16                         			CALL	6				; ENDCMD
  522/ 2A7 :                            
  523/ 2A7 :                            ;------------------------------------------------------------------------------
  524/ 2A7 : 1F                         RETERR:		CALL	15				; ERROR
  525/ 2A8 : 08                         			DB		8				; 8 (return without gosub)
  526/ 2A9 :                            
  527/ 2A9 :                            ;------------------------------------------------------------------------------
  528/ 2A9 :                            ; forward to UNTIL
  529/ 2A9 : 74 5F                      UNTIL:		BRA		UNTIL0			; redirect to real code
  530/ 2AB :                            
  531/ 2AB :                            ;------------------------------------------------------------------------------
  532/ 2AB :                            ; REM
  533/ 2AB : 20 9A 01                   REMCMD:		JSR		TOEOLN			; advance to end of line
  534/ 2AE : C6 FF                      			LD		A, @-1, P2	; back one char
  535/ 2B0 : 16                         			CALL	6				; ENDCMD
  536/ 2B1 :                            
  537/ 2B1 :                            ;------------------------------------------------------------------------------
  538/ 2B1 :                            ; IF
  539/ 2B1 : 10                         IFCMD:		CALL	0				; RELEXP get condition
  540/ 2B2 : 15                         			CALL	5				; APULL pop it into EA
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 10 - 2024年05月30日 15時32分15秒


  541/ 2B3 : 58                         			OR		A, E			; check for zero
  542/ 2B4 : 6C F5                      			BZ		REMCMD			; false: advance to end of line
  543/ 2B6 : 23 D4 01                   			PLI		P3, =CMDTB6		; process THEN (may be missing)
  544/ 2B9 : 1B                         			CALL	11				; CMPTOK
  545/ 2BA :                            
  546/ 2BA :                            ;------------------------------------------------------------------------------
  547/ 2BA :                            ; LINK
  548/ 2BA : 10                         LINK:		CALL	0				; RELEXP get link address
  549/ 2BB : 22 CB 04                   			PLI		P2, =DOLAL6-1	; save P2, put return vector into P2
  550/ 2BE : 15                         			CALL	5				; APULL pop link address
  551/ 2BF : 57                         			PUSH	P3				; push P3 on stack
  552/ 2C0 : 56                         			PUSH	P2				; put return vector on stack
  553/ 2C1 : BD E8                      			SUB		EA, ONE			; adjust link address
  554/ 2C3 : 08                         			PUSH	EA				; push on stack
  555/ 2C4 : 85 C6                      			LD		EA, EXTRAM		; load P2 with base of variables
  556/ 2C6 : 46                         			LD		P2, EA
  557/ 2C7 : 5C                         			RET						; return to link address
  558/ 2C8 :                            ; note: the stack frame is (before RET):
  559/ 2C8 :                            ;		P2 = variables
  560/ 2C8 :                            ;		Top:	linkaddress-1	(pulled by RET here)
  561/ 2C8 :                            ;				returnvector-1	(pulled by RET in called program)
  562/ 2C8 :                            ;				saved P3		(restored in returnvector stub)
  563/ 2C8 :                            ;				saved P2		(restored in returnvector stub)
  564/ 2C8 :                            
  565/ 2C8 :                            ;------------------------------------------------------------------------------
  566/ 2C8 : 46 4F 52                   CMDTB7:		DB		'FOR'
  567/ 2CB : E4                         			DB		0xe4			; to FOR
  568/ 2CC : 44 4F                      			DB		'DO'
  569/ 2CE : A7                         			DB		0xa7			; to DO
  570/ 2CF : 4F 4E                      			DB		'ON'
  571/ 2D1 : 8F                         			DB		0x8f			; to ON
  572/ 2D2 : 43 4C 45 41 52             			DB		'CLEAR'
  573/ 2D7 : 85                         			DB		0x85			; to CLEAR
  574/ 2D8 : 80                         			DB		0x80			; to EXEC3
  575/ 2D9 :                            
  576/ 2D9 :                            ;------------------------------------------------------------------------------
  577/ 2D9 :                            ; handle several commands for direct/program mode
  578/ 2D9 : 23 2C 04                   EXEC3:		PLI		P3, =CMDTB8
  579/ 2DC : 1B                         			CALL	11				; CMPTOK
  580/ 2DD :                            
  581/ 2DD :                            ;------------------------------------------------------------------------------
  582/ 2DD :                            ; CLEAR cmd
  583/ 2DD : 20 CE 05                   CLEAR:		JSR		INITA1			; do warm initialization
  584/ 2E0 : 16                         			CALL	6				; ENDCMD
  585/ 2E1 :                            
  586/ 2E1 :                            ;------------------------------------------------------------------------------
  587/ 2E1 :                            ; ON cmd
  588/ 2E1 : 10                         ON:			CALL	0				; RELEXP get expression
  589/ 2E2 : 1C                         			CALL	12				; EXPECT check if comma follows
  590/ 2E3 : 2C                         			DB		','    
  591/ 2E4 : 01                         			DB		1				; if not, continue next instruction
  592/ 2E5 : 15                         ON1:		CALL	5				; APULL get expression
  593/ 2E6 : D4 01                      			AND		A, =1			; has it bit 0 set?
  594/ 2E8 : 6C 07                      			BZ		ON2				; no, skip
  595/ 2EA : CD E6                      			ST		A, BRKFLG		; store nonzero in BRKFLG
  596/ 2EC : 10                         			CALL	0				; RELEXP get INTA vector expression
  597/ 2ED : 15                         			CALL	5				; APULL into EA
  598/ 2EE : 8D E2                      			ST		EA, INTAVC		; set as INTA call vector
  599/ 2F0 : 16                         			CALL	6				; ENDCMD done
  600/ 2F1 :                            
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 11 - 2024年05月30日 15時32分15秒


  601/ 2F1 :                            ; assume here another bit set
  602/ 2F1 : 10                         ON2:		CALL	0				; RELEXP get INTB vector expression
  603/ 2F2 : 15                         			CALL	5				; APULL into EA
  604/ 2F3 : 8D E4                      			ST		EA, INTBVC		; set as INTB call vector
  605/ 2F5 : 16                         			CALL	6				; ENDCMD done
  606/ 2F6 :                            
  607/ 2F6 :                            ;------------------------------------------------------------------------------
  608/ 2F6 :                            ; DO cmd
  609/ 2F6 : 85 DA                      DO:			LD		EA, DOPTR		; get DO stack ptr
  610/ 2F8 : 57                         			PUSH	P3				; 	save P3
  611/ 2F9 : 47                         			LD		P3, EA			; into P3
  612/ 2FA : 85 CE                      			LD		EA, FORSTK		; put end of stack (FORSTK is adjacent)
  613/ 2FC : CD F6                      			ST		A, TMPF6		; into temporary
  614/ 2FE : 33                         			LD		EA, P3			; DO stack pointer
  615/ 2FF : 20 C9 03                   			JSR		CHKSBR			; check stack overflow
  616/ 302 : 32                         			LD		EA, P2			; get current program pointer
  617/ 303 : 8F 02                      			ST		EA, @02, P3		; push on DO stack
  618/ 305 : 33                         			LD		EA, P3    		; and save new DO stack ptr
  619/ 306 : 5F                         			POP		P3				;   restore P3
  620/ 307 : 8D DA                      DO1:		ST		EA, DOPTR
  621/ 309 : 16                         			CALL	6				; ENDCMD done
  622/ 30A :                            ;;			RET						; done
  623/ 30A :                            
  624/ 30A :                            ;------------------------------------------------------------------------------
  625/ 30A :                            	;UNTIL command
  626/ 30A : 10                         UNTIL0:		CALL	0				; RELEXP get condition
  627/ 30B : 85 DA                      			LD		EA, DOPTR		; get DO stack ptr
  628/ 30D : BD CC                      			SUB		EA, DOSTK		; subtrack stack base
  629/ 30F : 58                         			OR		A,E				; is empty?
  630/ 310 : 7C 02                      			BNZ		UNTIL1			; no, continue
  631/ 312 :                            									; otherwise throw error 11
  632/ 312 : 1F                         			CALL	15				; ERROR
  633/ 313 : 0B                         			DB		0x0b			; 11 (UNTIL without DO)
  634/ 314 : 15                         UNTIL1:		CALL	5				; APULL condition into EA
  635/ 315 : 58                         			OR		A,E				; is false?
  636/ 316 : 6C 07                      			BZ		UNTIL2			; yes, skip
  637/ 318 : 85 DA                      			LD		EA, DOPTR		; no, discard DO loop from stack
  638/ 31A : BC 02 00                   			SUB		EA, =0002		; 1 level
  639/ 31D : 74 E8                      			BRA		DO1				; store back DO stack ptr and exit
  640/ 31F : 85 DA                      UNTIL2:		LD		EA, DOPTR		; do loop again
  641/ 321 : 46                         			LD		P2, EA			; get DO stack ptr
  642/ 322 : 82 FE                      			LD		EA, -2, P2		; get last level stored
  643/ 324 : 46                         			LD		P2, EA			; as new program pointer -> redo loop
  644/ 325 : 16                         			CALL	6				; ENDCMD
  645/ 326 :                            ;;			RET						; done	
  646/ 326 :                            
  647/ 326 :                            ;------------------------------------------------------------------------------
  648/ 326 :                            ; for comparison of FOR keyword STEP
  649/ 326 : 53 54 45 50                CMDTB9:		DB		'STEP'
  650/ 32A : 96                         			DB		0x96			; to FOR2
  651/ 32B : 98                         			DB		0x98			; to FOR3
  652/ 32C :                            
  653/ 32C :                            ; for comparison of FOR keyword TO
  654/ 32C : 54 4F                      CMDT10:		DB		'TO'
  655/ 32E : 8D                         			DB		0x8d			; to FOR1
  656/ 32F : FD                         			DB		0xfd			; to SNERR2 (syntax error)
  657/ 330 :                            
  658/ 330 : 20 75 05                   FOR:		JSR		GETVAR			; get a variable address on stack
  659/ 333 : 7A                         			DB		0x7a			; none found: goto SNERR2 (syntax error)
  660/ 334 : 1C                         			CALL	12				; EXPECT a '='
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 12 - 2024年05月30日 15時32分15秒


  661/ 335 : 3D                         			DB		'='
  662/ 336 : 77                         			DB		0x77			; none found: goto SNERR2 (syntax error)
  663/ 337 : 10                         			CALL	0				; RELEXP get initial expression
  664/ 338 : 23 2C 03                   			PLI		P3, =CMDT10		; expect TO keyword (SNERR if not)
  665/ 33B : 1B                         			CALL	11				; CMPTOK
  666/ 33C :                            
  667/ 33C : 10                         FOR1:		CALL	0				; RELEXP get end expression
  668/ 33D : 23 26 03                   			PLI		P3, =CMDTB9		; check for STEP keyword, to FOR2 if found, to FOR3 if not
  669/ 340 : 1B                         			CALL	11				; CMPTOK
  670/ 341 :                            
  671/ 341 : 10                         FOR2:		CALL	0				; RELEXP get step expression
  672/ 342 : 74 04                      			BRA		FOR4			; skip
  673/ 344 : 85 E8                      FOR3:   	LD		EA, ONE			; push 1 as STEP on stack
  674/ 346 : 8F 02                      			ST		EA, @2, P3
  675/ 348 : 85 DC                      FOR4:		LD		EA, FORPTR		; get the FOR stack ptr
  676/ 34A : 56                         			PUSH	P2				;   save current program ptr
  677/ 34B : 46                         			LD		P2, EA			; into P2
  678/ 34C : 85 D0                      			LD		EA, BUFAD		; put end of stack (BUFAD is adjacent)
  679/ 34E : CD F6                      			ST		A, TMPF6		; into temporary
  680/ 350 : 32                         			LD		EA, P2			; FOR stack ptr
  681/ 351 : 20 C9 03                   			JSR		CHKSBR			; check stack overflow
  682/ 354 : 15                         			CALL	5				; APULL restore step value
  683/ 355 : 8E 02                      			ST		EA, @2, P2		; save at forstack+0
  684/ 357 : 15                         			CALL	5				; APULL restore end value
  685/ 358 : 8E 02                      			ST		EA, @2, P2		; save at forstack+2
  686/ 35A : 15                         			CALL	5				; APULL restore initial value
  687/ 35B : 09                         			LD		T, EA			; save in T
  688/ 35C : 15                         			CALL	5				; APULL restore variable address
  689/ 35D : 8D F6                      			ST		EA, TMPF6		; store address in temporary
  690/ 35F : CE 01                      			ST		A, @1, P2		; save low offset of var at forstack+4
  691/ 361 : 81 00                      			LD		EA, 0, SP		; get current program ptr
  692/ 363 : 8E 02                      			ST		EA, @2, P2		; save at forstack+5
  693/ 365 : 32                         			LD		EA, P2			; save new FOR stack ptr
  694/ 366 : 8D DC                      			ST		EA, FORPTR
  695/ 368 : 85 F6                      			LD		EA, TMPF6		; get variable address
  696/ 36A : 46                         			LD		P2, EA			; into P2
  697/ 36B : 0B                         			LD		EA, T			; initial value
  698/ 36C : 8A 00                      			ST		EA, 0, P2		; save in variable
  699/ 36E : 5E                         FOR5:		POP		P2				; restore program pointer
  700/ 36F : 16                         			CALL	6				; ENDCMD
  701/ 370 :                            ; note the FOR stack frame looks like the following:
  702/ 370 :                            ;		offset 0: DW step value
  703/ 370 :                            ;		offset 2: DW end value
  704/ 370 :                            ;		offset 4: DB variable low offset
  705/ 370 :                            ;		offset 5: DW program pointer of first statement of loop
  706/ 370 :                            
  707/ 370 : 1F                         NXERR:		CALL	15				; ERROR
  708/ 371 : 0A                         			DB		10				; 10 (NEXT without FOR)
  709/ 372 :                            
  710/ 372 :                            ; NEXT command
  711/ 372 : 20 75 05                   NEXT0:		JSR		GETVAR			; get variable address on stack
  712/ 375 : 38                         			DB		0x38			; no var found, goto SNERR2 (syntax error)
  713/ 376 : 15                         			CALL	5				; APULL restore address
  714/ 377 : 09                         			LD		T, EA			; put into T
  715/ 378 : 85 DC                      NEXT1:		LD		EA, FORPTR		; get FOR stack ptr
  716/ 37A : BD CE                      			SUB		EA, FORSTK		; subtract base
  717/ 37C : 6C F2                      			BZ		NXERR			; is empty? yes, NEXT without FOR error
  718/ 37E : 85 DC                      			LD		EA, FORPTR		; get FOR stack ptr again
  719/ 380 : BC 07 00                   			SUB		EA, =0007		; discard current frame
  720/ 383 : 8D DC                      			ST		EA, FORPTR		; save it for the case loop ends
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 13 - 2024年05月30日 15時32分15秒


  721/ 385 : 56                         			PUSH	P2				; save program pointer
  722/ 386 : 46                         			LD		P2, EA			; point to base of current FOR frame
  723/ 387 : 0B                         			LD		EA, T			; get var address
  724/ 388 : FA 04                      			SUB		A, 4, P2		; subtract var addr of this frame
  725/ 38A : 6C 03                      			BZ		NEXT2			; is the same?, yes skip (found)
  726/ 38C : 5E                         			POP		P2				; restore P2
  727/ 38D : 74 E9                      			BRA		NEXT1			; try another loop - assume jump out of loop
  728/ 38F : C2 01                      NEXT2:		LD		A, 1, P2		; step value (high byte)
  729/ 391 : 64 09                      			BP		NEXT3			; is step positive? yes, skip
  730/ 393 : 20 AE 03                   			JSR		NXADD			; add step and compare with end value
  731/ 396 : E4 FF                      			XOR		A, =0xff		; compare with -1
  732/ 398 : 6C 07                      			BZ		NEXT5			; zero? yes, end of loop not yet reached
  733/ 39A : 74 03                      			BRA		NEXT4			; skip
  734/ 39C : 20 AE 03                   NEXT3:		JSR		NXADD			; add step and compare with end value
  735/ 39F : 64 CD                      NEXT4:		BP		FOR5			; end of loop done, continue after NEXT
  736/ 3A1 : 82 05                      NEXT5: 		LD		EA, 5, P2		; get start of loop program pointer
  737/ 3A3 : 5E                         			POP		P2				; drop P2
  738/ 3A4 : 46                         			LD		P2, EA			; set start of loop again
  739/ 3A5 : 85 DC                      			LD		EA, FORPTR		; get FOR stack ptr
  740/ 3A7 : B4 07 00                   			ADD		EA, =0007		; push loop frame again
  741/ 3AA : 8D DC                      			ST		EA, FORPTR		; save new FOR ptr
  742/ 3AC : 16                         			CALL	6				; ENDCMD
  743/ 3AD :                            ;;			RET						; done
  744/ 3AD :                            
  745/ 3AD : 1F                         SNERR2:		CALL	15				; ERROR
  746/ 3AE : 04                         			DB		4				; 4 (syntax error)
  747/ 3AF :                            
  748/ 3AF :                            ;------------------------------------------------------------------------------
  749/ 3AF :                            ; add step and compare with end value
  750/ 3AF : 85 C6                      NXADD:		LD		EA, EXTRAM		; variable base
  751/ 3B1 : C2 04                      			LD		A, 4, P2    	; get variable offset
  752/ 3B3 : 57                         			PUSH	P3				;   save P3
  753/ 3B4 : 47                         			LD		P3, EA			; into EA
  754/ 3B5 : 83 00                      			LD		EA, 0, P3		; get variable value
  755/ 3B7 : B2 00                      			ADD		EA, 0, P2		; add step value
  756/ 3B9 : 8B 00                      			ST		EA, 0, P3		; store new variable
  757/ 3BB : 5F                         			POP		P3				;  restore P3
  758/ 3BC : BA 02                      			SUB		EA, 2, P2		; compare with end value
  759/ 3BE : 6C 04                      			BZ		NXADD2			; same?
  760/ 3C0 : 01                         			XCH		A, E			; no, swap: A = high byte
  761/ 3C1 : D4 80                      NXADD1:		AND		A, =0x80		; mask out sign bit
  762/ 3C3 : 5C                         			RET						; return
  763/ 3C4 : 01                         NXADD2:		XCH		A, E			; swap: A = high byte
  764/ 3C5 : 7C FA                      			BNZ		NXADD1			; not same? get high byte
  765/ 3C7 : C4 FF                      			LD		A, =0xff		; set A = -1
  766/ 3C9 : 5C                         			RET						; return
  767/ 3CA :                            
  768/ 3CA :                            ;------------------------------------------------------------------------------	
  769/ 3CA :                            ; check for SBR stack overflow
  770/ 3CA :                            ; EA contains current stack pointer, TMPF6 contains limit
  771/ 3CA : FD F6                      CHKSBR:		SUB		A, TMPF6		; subrack limit
  772/ 3CC : 64 01                      			BP		NSERR			; beyond limit?
  773/ 3CE : 5C                         			RET						; no, exit
  774/ 3CF :                            									; otherwise nesting too deep error
  775/ 3CF : 1F                         NSERR:		CALL	15				; ERROR
  776/ 3D0 : 09                         			DB		9				; 9 (nesting too deep)
  777/ 3D1 :                            
  778/ 3D1 :                            ;------------------------------------------------------------------------------
  779/ 3D1 : 1F                         SUERR:		CALL	15				; ERROR
  780/ 3D2 : 02                         			DB		2				; 2 (stmt used improperly)
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 14 - 2024年05月30日 15時32分15秒


  781/ 3D3 :                            
  782/ 3D3 :                            ;------------------------------------------------------------------------------
  783/ 3D3 :                            ; INPUT handler
  784/ 3D3 : C5 C2                      INPUT0:		LD		A, INPMOD		; is in direct mode?
  785/ 3D5 : 6C FA                      			BZ		SUERR			; yes, this is an error!
  786/ 3D7 : 32                         			LD		EA, P2			; save current program ptr temporarily
  787/ 3D8 : 8D F2                      			ST		EA, TMPF2
  788/ 3DA : 20 75 05                   INPUT1:		JSR		GETVAR			; get variable address on stack
  789/ 3DD : 29                         			DB		0x29			; no variable, goto INPUT3 (could be $)
  790/ 3DE : C4 03                      			LD		A, =03			; set mode 3, swap buffers (P2 is input buffer)
  791/ 3E0 : 20 23 04                   			JSR		SWPBUF
  792/ 3E3 : 20 55 08                   			JSR		GETLN			; get line into input buffer
  793/ 3E6 : 10                         INPUT2:		CALL	0				; RELEXP get expression from input buffer
  794/ 3E7 : 15                         			CALL	5				; APULL into EA
  795/ 3E8 : 09                         			LD		T, EA			; save into T
  796/ 3E9 : 15                         			CALL	5				; APULL get variable address
  797/ 3EA : 57                         			PUSH	P3				;   save P3
  798/ 3EB : 47                         			LD		P3, EA			; into P3
  799/ 3EC : 0B                         			LD		EA, T			; obtain expression
  800/ 3ED : 8B 00                      			ST		EA, 0, P3		; save into variable
  801/ 3EF : 5F                         			POP		P3				;   restore P3
  802/ 3F0 : C4 01                      			LD		A, =01			; set mode 1, swap buffers (P2 is program ptr)
  803/ 3F2 : 20 23 04                   			JSR		SWPBUF
  804/ 3F5 : 1C                         			CALL	12				; EXPECT a comma
  805/ 3F6 : 2C                         			DB		','
  806/ 3F7 : 2C                         			DB		0x2c			; if not found, exit via INPUT5
  807/ 3F8 : 20 75 05                   			JSR		GETVAR			; get another variable
  808/ 3FB : D6                         			DB		0xd6			; if none found, goto SUERR (error 2)
  809/ 3FC :                            									; does not accept $ any more here
  810/ 3FC : C4 03                      			LD		A, =03			; set mode 3, swap buffers (P2 is input buffer)
  811/ 3FE : 20 23 04                   			JSR		SWPBUF
  812/ 401 : 1C                         			CALL	12				; EXPECT an optional comma in input buffer
  813/ 402 : 2C                         			DB		','
  814/ 403 : 01                         			DB		1				; none found, ignore
  815/ 404 : 74 E0                      			BRA		INPUT2			; process the next variable
  816/ 406 :                            
  817/ 406 :                            ; process $expr for string input
  818/ 406 : 1C                         INPUT3:		CALL	12				; EXPECT a $ here
  819/ 407 : 24                         			DB		'$'
  820/ 408 : C9                         			DB		0xc9			; none found, goto SUERR
  821/ 409 : 11                         			CALL	1				; FACTOR get string buffer address
  822/ 40A : C4 03                      			LD		A, =03			; set mode 3, swap buffers (P2 is input buffer)
  823/ 40C : 20 23 04                   			JSR		SWPBUF
  824/ 40F : 20 55 08                   			JSR		GETLN			; get line of input
  825/ 412 : 15                         			CALL	5				; APULL get buffer address
  826/ 413 : 57                         			PUSH	P3				;   save P3
  827/ 414 : 47                         			LD		P3, EA			; into P3
  828/ 415 : C6 01                      INPUT4:		LD		A, @1, P2		; copy input from buffer into string
  829/ 417 : CF 01                      			ST		A, @1, P3
  830/ 419 : E4 0D                      			XOR		A, =CR			; until CR seen
  831/ 41B : 7C F8                      			BNZ		INPUT4
  832/ 41D : 5F                         			POP		P3				;   restore P3
  833/ 41E : C4 01                      			LD		A, =01			; set mode 1 again, swap buffers (P2 is program ptr)
  834/ 420 : 20 23 04                   			JSR		SWPBUF			
  835/ 423 : 16                         INPUT5:		CALL	6				; ENDCMD done
  836/ 424 :                            
  837/ 424 :                            ;------------------------------------------------------------------------------
  838/ 424 :                            ; save input mode and swap buffers
  839/ 424 : CD C2                      SWPBUF:		ST		A, INPMOD		; store new input mode
  840/ 426 : 85 F0                      			LD		EA, TMPF0		; swap buffer addresses
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 15 - 2024年05月30日 15時32分15秒


  841/ 428 : 4E                         			XCH		P2, EA			; TMPF0 normally contains input buffer address
  842/ 429 : 8D F0                      			ST		EA, TMPF0
  843/ 42B : 5C                         			RET
  844/ 42C :                            
  845/ 42C :                            ;------------------------------------------------------------------------------
  846/ 42C :                            ; several more commands
  847/ 42C : 44 45 4C 41 59             CMDTB8:		DB		'DELAY'
  848/ 431 : 9A                         			DB		0x9a			; to DELAY
  849/ 432 : 49 4E 50 55 54             			DB		'INPUT'
  850/ 437 : 8F                         			DB		0x8f			; to INPUT
  851/ 438 : 50 52 49 4E 54             			DB		'PRINT'
  852/ 43D : 8B                         			DB		0x8b			; to PRINT
  853/ 43E : 50 52                      			DB		'PR'
  854/ 440 : 88                         			DB		0x88			; to PRINT
  855/ 441 : 53 54 4F 50                			DB		'STOP'
  856/ 445 : 91                         			DB		0x91			; to STOP
  857/ 446 : 9D                         			DB		0x9d			; default to ASSIGN
  858/ 447 :                            
  859/ 447 :                            ;------------------------------------------------------------------------------
  860/ 447 :                            ; INPUT cmd
  861/ 447 : 74 8A                      INPUT:		BRA		INPUT0			; INPUT handler
  862/ 449 :                            
  863/ 449 :                            ;------------------------------------------------------------------------------
  864/ 449 :                            ; PRINT cmd
  865/ 449 : 24 D2 04                   PRINT:		JMP		PRINT0			; PRINT handler
  866/ 44C :                            
  867/ 44C :                            ;------------------------------------------------------------------------------
  868/ 44C :                            ; DELAY cmd
  869/ 44C : 10                         DELAY:		CALL	0				; RELEXP get delay expression
  870/ 44D : 15                         			CALL	5				; APULL into EA
  871/ 44E : A4 3F 00                   			LD		T, =0x003f		; multiply with 63
  872/ 451 : 2C                         			MPY		EA, T
  873/ 452 : 0B                         			LD		EA, T			; into EA
  874/ 453 : 20 DC 09                   			JSR		DELAYC			; do delay
  875/ 456 : 16                         			CALL	6				; ENDCMD
  876/ 457 :                            ;;;			RET						; done
  877/ 457 :                            
  878/ 457 :                            ;------------------------------------------------------------------------------
  879/ 457 :                            ; STOP cmd
  880/ 457 : 24 A2 00                   STOP:		JMP		MAINLP			; directly enter main loop
  881/ 45A :                            
  882/ 45A :                            ;------------------------------------------------------------------------------
  883/ 45A :                            ; left hand side (LHS) operators for assigment
  884/ 45A : 53 54 41 54                CMDTB4:		DB		'STAT'
  885/ 45E : 89                         			DB		0x89			; to STATLH
  886/ 45F : 40                         			DB		'@'
  887/ 460 : 92                         			DB		0x92			; to ATLH
  888/ 461 : 24                         			DB		'$'
  889/ 462 : B1                         			DB		0xb1			; to DOLALH
  890/ 463 : 9E                         			DB		0x9e			; default case to ASSIG1   
  891/ 464 :                            
  892/ 464 :                            ;------------------------------------------------------------------------------
  893/ 464 :                            ; handle assignments
  894/ 464 : 23 5A 04                   ASSIGN:		PLI		P3, =CMDTB4
  895/ 467 : 1B                         			CALL	11				; CMPTOK
  896/ 468 :                            
  897/ 468 :                            ;------------------------------------------------------------------------------
  898/ 468 :                            ; STAT on left hand side
  899/ 468 : 1C                         STATLH:		CALL	12 				; EXPECT an equal symbol
  900/ 469 : 3D                         			DB		'='				;  
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 16 - 2024年05月30日 15時32分15秒


  901/ 46A : 67                         			DB		0x67			; not found, goto SNERR    
  902/ 46B : 10                         			CALL	0				; RELEXP get the right hand side
  903/ 46C : 15                         			CALL	5				; APULL into EA
  904/ 46D : 07                         			LD		S, A			; put into SR (only low byte)  
  905/ 46E : C4 01                      			LD		A, =1			; suppress potential INT that could
  906/ 470 : CD E7                      			ST		A, NOINT		; result from changing SA/SB
  907/ 472 : 16                         			CALL	6				; ENDCMD
  908/ 473 :                            
  909/ 473 :                            ;------------------------------------------------------------------------------
  910/ 473 :                            ; @ on left hand side (POKE)
  911/ 473 : 11                         ATLH:		CALL	1				; FACTOR get non-boolean expression
  912/ 474 : 1C                         			CALL	12				; EXPECT an equal symbol
  913/ 475 : 3D                         			DB		'='
  914/ 476 : 5B                         			DB		0x5b			; not found, goto SNERR (syntax error)
  915/ 477 : 10                         			CALL	0				; RELEXP get right hand side
  916/ 478 : 15                         			CALL	5				; APULL into EA
  917/ 479 : 09                         			LD		T, EA			; into T
  918/ 47A : 15                         			CALL	5				; APULL get target address
  919/ 47B : 57                         			PUSH	P3				;   save P3
  920/ 47C : 47                         			LD		P3, EA			; into P3
  921/ 47D : 0B                         			LD		EA, T			; RHS into EA
  922/ 47E : CB 00                      			ST		A, 0, P3		; store low byte at address
  923/ 480 : 5F                         			POP		P3
  924/ 481 : 16                         			CALL	6				; ENDCMD
  925/ 482 :                            ;;;			RET
  926/ 482 :                            
  927/ 482 :                            ;------------------------------------------------------------------------------
  928/ 482 :                            ; default case for assign (VAR = expr)
  929/ 482 : 20 75 05                   ASSIG1:		JSR		GETVAR			; get a variable
  930/ 485 : 4C                         			DB		0x4c			; if not var, goto DOLAL4 (assume $xxxx)
  931/ 486 : 1C                         			CALL	12				; EXPECT an equal symbol
  932/ 487 : 3D                         			DB		'='
  933/ 488 : 49                         			DB		0x49			; not found, go to SNERR
  934/ 489 : 10                         			CALL	0				; RELEXP get right hand side
  935/ 48A : 15                         			CALL	5				; APULL into EA
  936/ 48B : 09                         			LD		T, EA			; into T
  937/ 48C : 15                         			CALL	5				; APULL get variable address
  938/ 48D : 57                         			PUSH	P3				;   save P3
  939/ 48E : 47                         			LD		P3, EA			; into P3
  940/ 48F : 0B                         			LD		EA, T			; get RHS
  941/ 490 : 8B 00                      			ST		EA, 0, P3		; store result into variable
  942/ 492 : 5F                         			POP		P3				;   restore P3
  943/ 493 : 16                         			CALL	6				; ENDCMD done
  944/ 494 :                            
  945/ 494 :                            ;------------------------------------------------------------------------------
  946/ 494 :                            ; $ on left hand side
  947/ 494 : 11                         DOLALH:		CALL	1				; FACTOR get target address
  948/ 495 : 1C                         			CALL	12				; EXPECT an equal symbol
  949/ 496 : 3D                         			DB		'='
  950/ 497 : 3A                         			DB		0x3a			; if not found, goto SNERR
  951/ 498 : C2 00                      			LD		A, 0, P2		; get next char from program
  952/ 49A : E4 22                      			XOR		A, =0x22		; is double quote?
  953/ 49C : 7C 1C                      			BNZ		DOLAL3			; not a constant string, may be string assign
  954/ 49E : C6 01                      			LD		A, @1, P2		; skip over quote
  955/ 4A0 : 15                         			CALL	5				; APULL get target address
  956/ 4A1 : 57                         			PUSH	P3				;   save P3
  957/ 4A2 : 47                         			LD		P3, EA			; into P3
  958/ 4A3 : C6 01                      DOLAL1:		LD		A, @1, P2		; get string char from program buffer
  959/ 4A5 : E4 22                      			XOR		A, =0x22		; is double quote?
  960/ 4A7 : 6C 0A                      			BZ		DOLAL2			; yes, end of string, skip
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 17 - 2024年05月30日 15時32分15秒


  961/ 4A9 : E4 2F                      			XOR		A, =0x2f		; is CR?
  962/ 4AB : 6C 22                      			BZ		EQERR			; yes, ending quote missing error 
  963/ 4AD : E4 0D                      			XOR		A, =0x0d		; convert back to original char
  964/ 4AF : CF 01                      			ST		A, @1, P3		; store into target buffer
  965/ 4B1 : 74 F0                      			BRA		DOLAL1			; loop
  966/ 4B3 :                            
  967/ 4B3 : C4 0D                      DOLAL2:		LD		A, =CR			; terminate target string
  968/ 4B5 : CB 00                      			ST		A, 0, P3
  969/ 4B7 : 5F                         			POP		P3				;   restore P3
  970/ 4B8 : 19                         			CALL	9				; GETCHR get next char from program
  971/ 4B9 : 16                         			CALL	6				; ENDCMD done
  972/ 4BA :                            
  973/ 4BA :                            ; assume string assign
  974/ 4BA : 1C                         DOLAL3:		CALL	12				; EXPECT a $
  975/ 4BB : 24                         			DB		'$'
  976/ 4BC : 15                         			DB		0x15			; not found, goto SNERR
  977/ 4BD : 11                         			CALL	1				; FACTOR get source address
  978/ 4BE : 15                         			CALL	5				; APULL into EA
  979/ 4BF : 56                         			PUSH	P2				;   save P2
  980/ 4C0 : 46                         			LD		P2, EA			; into P2
  981/ 4C1 :                            
  982/ 4C1 : 15                         DOLAL4:		CALL	5				; APULL get target address
  983/ 4C2 : 57                         			PUSH	P3				;   save P3
  984/ 4C3 : 47                         			LD		P3, EA			; into P3
  985/ 4C4 : C6 01                      DOLAL5:		LD		A, @1, P2		; move byte from source to targer
  986/ 4C6 : CF 01                      			ST		A, @1, P3
  987/ 4C8 : E4 0D                      			XOR		A, =CR			; compare with CR
  988/ 4CA : 7C F8                      			BNZ		DOLAL5			; not yet, continue copying
  989/ 4CC :                            
  990/ 4CC :                            ;------------------------------------------------------------------------------
  991/ 4CC :                            ; This location is also the return point form LINK
  992/ 4CC : 5F                         DOLAL6:		POP		P3				;   restore P3
  993/ 4CD : 5E                         			POP		P2				;   restore P2
  994/ 4CE : 16                         			CALL	6				; ENDCMD
  995/ 4CF :                            
  996/ 4CF :                            ;------------------------------------------------------------------------------
  997/ 4CF : 1F                         EQERR:		CALL	15				; ERROR
  998/ 4D0 : 06                         			DB		6				; 6 (ending quote missing)
  999/ 4D1 :                            
 1000/ 4D1 :                            ;------------------------------------------------------------------------------
 1001/ 4D1 : 1F                         SNERR:		CALL	15				; ERROR    
 1002/ 4D2 : 04                         			DB		4				; 4 (syntax error)
 1003/ 4D3 :                            
 1004/ 4D3 :                            ;------------------------------------------------------------------------------
 1005/ 4D3 :                            ; PRINT handler
 1006/ 4D3 : C2 00                      PRINT0:		LD		A, 0, P2		; get char from program
 1007/ 4D5 : E4 22                      			XOR		A, =0x22		; is double quote?
 1008/ 4D7 : 7C 11                      			BNZ		PRINT2			; no, not a string print
 1009/ 4D9 :                            
 1010/ 4D9 :                            ; print a string constant
 1011/ 4D9 : C6 01                      			LD		A, @1, P2		; skip over quote
 1012/ 4DB : C6 01                      PRINT1:		LD		A, @1, P2		; get next char
 1013/ 4DD : E4 22                      			XOR		A, =0x22		; is double quote?
 1014/ 4DF : 6C 18                      			BZ		PRINT4			; yes, done with print
 1015/ 4E1 : E4 2F                      			XOR		A, =0x2f		; is CR?
 1016/ 4E3 : 6C EA                      			BZ		EQERR			; yes, error missing end quote
 1017/ 4E5 : E4 0D                      			XOR		A, =0x0d		; convert back to original char
 1018/ 4E7 : 17                         			CALL	7				; PUTC emit 
 1019/ 4E8 : 74 F1                      			BRA		PRINT1			; loop
 1020/ 4EA :                            
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 18 - 2024年05月30日 15時32分15秒


 1021/ 4EA :                            ; print a string variable
 1022/ 4EA : 1C                         PRINT2:		CALL	12				; EXPECT a $
 1023/ 4EB : 24                         			DB		'$'
 1024/ 4EC : 09                         			DB		0x09			; if not found, goto PRINT3 (could be expression)
 1025/ 4ED : 11                         			CALL	1				; FACTOR get source address
 1026/ 4EE : 15                         			CALL	5				; APULL into EA
 1027/ 4EF : 56                         			PUSH	P2				;   save P2
 1028/ 4F0 : 46                         			LD		P2, EA			; into P2
 1029/ 4F1 : 1E                         			CALL	14				; PRTLN print the string
 1030/ 4F2 : 5E                         			POP		P2				;   restore P2
 1031/ 4F3 : 74 04                      			BRA		PRINT4			; continue in PRINT
 1032/ 4F5 :                            
 1033/ 4F5 :                            ; print an expression
 1034/ 4F5 : 10                         PRINT3:		CALL	0				; RELEXP get expression
 1035/ 4F6 : 20 04 05                   			JSR		PRNUM			; print numeric
 1036/ 4F9 :                            
 1037/ 4F9 :                            ; print next field
 1038/ 4F9 : 19                         PRINT4:		CALL	9				; GETCHR get next character
 1039/ 4FA : 1C                         			CALL	12				; EXPECT a comma
 1040/ 4FB : 2C                         			DB		','
 1041/ 4FC : 03                         			DB		3				; if not found, goto PRINT5 (check for semicolon)
 1042/ 4FD : 74 D4                      			BRA		PRINT0			; process next field
 1043/ 4FF :                            
 1044/ 4FF : 1C                         PRINT5:		CALL	12				; EXPECT a semicolon
 1045/ 500 : 3B                         			DB		';'
 1046/ 501 : 02                         			DB		2				; if not found, goto PRINT6 do a CRLF
 1047/ 502 : 16                         			CALL	6				; ENDCMD semicolon: terminate without CRLF
 1048/ 503 : 18                         PRINT6:		CALL	8				; CRLF do a new line
 1049/ 504 : 16                         			CALL	6				; ENDCMD done
 1050/ 505 :                            
 1051/ 505 :                            ;------------------------------------------------------------------------------
 1052/ 505 :                            ; pop number off stack and print it
 1053/ 505 : 83 FE                      PRNUM:		LD 		EA, -2, P3		; get last number on stack
 1054/ 507 : 01                         			XCH		A, E    		; check high byte
 1055/ 508 : 64 09                      			BP		PRNUM1			; is positive? yes, skip
 1056/ 50A : 01                         			XCH		A, E    		; restore original number
 1057/ 50B : 1A                         			CALL	10    			; NEGATE number
 1058/ 50C : 8B FE                      			ST		EA, -2, P3		; store as positive number on stack
 1059/ 50E : C4 2D                      			LD		A, ='-'			; load minus symbol
 1060/ 510 : 17                         			CALL	7				; PUTC emit it
 1061/ 511 : 74 03                      			BRA		PRNUM2			; skip
 1062/ 513 : C4 20                      PRNUM1:		LD		A, =SPACE		; emit a blank
 1063/ 515 : 17                         			CALL	7    			; PUTC
 1064/ 516 : C4 00                      PRNUM2:		LD		A, =0			; clear counter for characters
 1065/ 518 : CD FE                      			ST		A, TMPFE		; 
 1066/ 51A : 15                         			CALL	5				; APULL get number  (is positive)
 1067/ 51B : 23 F6 FF                     			PLI		P3, =TMPF6		; save P3 and load TMPF6
 1068/ 51E : A4 0A 00                   PRNUM3:		LD		T, =10			; load divisor 10    
 1069/ 521 : 8D FC                      			ST		EA, TMPFC		; store dividend temporary
 1070/ 523 : 0D                         			DIV		EA, T			; divide by 10
 1071/ 524 : 08                         			PUSH	EA				; save remainder
 1072/ 525 : A4 0A 00                   			LD		T, =10			; multiplier 10
 1073/ 528 : 2C                         			MPY		EA, T			; multiply, is now (VAL DIV 10) * 10, i.e. last digit stripped
 1074/ 529 : 0B                         			LD		EA, T			; get this
 1075/ 52A : 1A                         			CALL	10    			; NEGATE
 1076/ 52B : B5 FC                      			ADD		EA, TMPFC		; extract least digit
 1077/ 52D : CF 01                      			ST		A, @1, P3		; push onto stack
 1078/ 52F : 95 FE                      			ILD		A, TMPFE		; increment char counter
 1079/ 531 : 3A                         			POP		EA    			; restore remainder
 1080/ 532 : 7C EA                      			BNZ		PRNUM3			; unless zero, loop for another digit
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 19 - 2024年05月30日 15時32分15秒


 1081/ 534 : 01                         			XCH		A, E			; also high byte
 1082/ 535 : 6C 03                      			BZ		PRNUM4			; if zero, go emitting
 1083/ 537 : 01                         			XCH		A, E    		; restore remainder
 1084/ 538 : 74 E4                      			BRA		PRNUM3			; loop for another digit
 1085/ 53A : C7 FF                      PRNUM4:  	LD		A, @-1, P3		; get last pushed digit first
 1086/ 53C : F4 30                      			ADD		A, ='0'			; make it ASCII digit    
 1087/ 53E : 17                         			CALL	7				; PUTC
 1088/ 53F : 9D FE                      			DLD		A, TMPFE		; decrement count	
 1089/ 541 : 7C F7                      			BNZ		PRNUM4    		; loop until all digits done
 1090/ 543 : C4 20                      			LD		A, =SPACE		; emit space
 1091/ 545 : 17                         			CALL	7				; PUTC
 1092/ 546 : 5F                         			POP		P3				; restore arithmetic stack pointer
 1093/ 547 : 5C                         			RET
 1094/ 548 :                            ;------------------------------------------------------------------------------
 1095/ 548 :                            ; print string pointed to by P2, until char has bit 7 is set or is CR
 1096/ 548 : C6 01                      PRTLN:		LD		A, @1, P2		; get next char from buffer
 1097/ 54A : E4 0D                      			XOR		A, =CR			; is CR?
 1098/ 54C : 6C 05                      			BZ		PRTLN1			; yes exit
 1099/ 54E : E4 0D                      			XOR 	A, =CR			; make original char again
 1100/ 550 : 17                         			CALL 	7				; PUTC emit it
 1101/ 551 : 64 F5                      			BP		PRTLN			; if positive, loop
 1102/ 553 : 5C                         PRTLN1		RET						; exit
 1103/ 554 :                            ;------------------------------------------------------------------------------
 1104/ 554 :                            ; get next char from buffer
 1105/ 554 : C6 01                      GETNXC:		LD		A, @1, P2		; advance P2
 1106/ 556 :                            ;------------------------------------------------------------------------------
 1107/ 556 :                            ; get character from buffer pointed to by P2, into A (call 9)
 1108/ 556 : C2 00                      GETCHR:		LD		A, 0, P2		; char from buffer
 1109/ 558 : D4 7F                      			AND		A, =0x7f		; mask 7 bits
 1110/ 55A : 48                         			LD		E, A			; into E
 1111/ 55B : E4 20                      			XOR		A, =SPACE		; is space?    
 1112/ 55D : 6C F5                      			BZ		GETNXC			; skip over it, loop to next    
 1113/ 55F : E4 2A                      			XOR		A, =0x2a		; is LF (SPACE xor 0x0a)?
 1114/ 561 : 6C F1                      			BZ		GETNXC			; yes, skip over it, loop to next    
 1115/ 563 : 40                         			LD		A, E			; back into A
 1116/ 564 : 6C EE                      			BZ		GETNXC			; if zero, loop over it
 1117/ 566 : 5C                         			RET
 1118/ 567 :                            ;------------------------------------------------------------------------------
 1119/ 567 :                            ; EXPECT char following in text, if not found (call 12)
 1120/ 567 :                            ; call it as:
 1121/ 567 :                            ;			CALL 12
 1122/ 567 :                            ;			DB	'chartomatch'
 1123/ 567 :                            ;			DB	offset to jump to if no match
 1124/ 567 : 3A                         EXPECT:		POP		EA				; get return addr
 1125/ 568 : B5 E8                      			ADD		EA, ONE    		; advance to following byte
 1126/ 56A : 08                         			PUSH	EA				; put return on stack again (continue here if matched)
 1127/ 56B : 57                         			PUSH	P3				; save P3
 1128/ 56C : 47                         			LD		P3, EA			; point to char to match
 1129/ 56D : C3 00                      			LD		A, 0, P3		; load char to match
 1130/ 56F : E2 00                      			XOR		A, 0, P2		; compare with buffer
 1131/ 571 : 5F                         			POP		P3				; restore P3
 1132/ 572 : 6C 23                      			BZ		GETVA3			; char matched, advance to next and exit
 1133/ 574 : 74 0C                      			BRA		GETVA1			; otherweise error
 1134/ 576 :                            
 1135/ 576 :                            ;------------------------------------------------------------------------------
 1136/ 576 :                            ; expect variable, and push it
 1137/ 576 :                            ; call as:
 1138/ 576 :                            ;			JSR GETVAR
 1139/ 576 :                            ;			DB	offset to jump to if not variable
 1140/ 576 : C2 00                      GETVAR:		LD		A, 0, P2		; get character from buffer
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 20 - 2024年05月30日 15時32分15秒


 1141/ 578 : 48                         			LD		E, A			; save in E
 1142/ 579 : FC 5B                      			SUB		A, ='Z'+1		; subtract 'Z'+1
 1143/ 57B : 64 05                      			BP		GETVA1			; is >=, skip
 1144/ 57D : 40                         			LD		A, E			; restore char
 1145/ 57E : FC 41                      			SUB		A, ='A'			; subtract 'A'
 1146/ 580 : 64 0D                      			BP		GETVA2			; is an alpha char, skip
 1147/ 582 :                            
 1148/ 582 :                            ; go to the offset that return address points to
 1149/ 582 : 3A                         GETVA1:		POP		EA				; pop return address (pointing to error code)
 1150/ 583 : 8D F6                      			ST		EA, TMPF6		; save in temporary
 1151/ 585 : 57                         			PUSH	P3				; save P3
 1152/ 586 : 47                         			LD		P3, EA			; get return addr in P3
 1153/ 587 : 85 EA                      			LD		EA, ZERO		; clear EA
 1154/ 589 : C3 01                      			LD		A, 1, P3		; get next location offset
 1155/ 58B : B5 F6                      			ADD		EA, TMPF6		; add return addr
 1156/ 58D : 5F                         			POP		P3				; restore P3
 1157/ 58E : 44                         			LD		PC, EA			; go to that offset (no variable found)
 1158/ 58F :                            
 1159/ 58F : 0E                         GETVA2:		SL		A				; is variable, make offset into var table
 1160/ 590 : 01                         			XCH		A, E			; put into E
 1161/ 591 : C4 00                      			LD		A, =0			; clear A
 1162/ 593 : 01                         			XCH		A, E			; make 16 bit unsigned
 1163/ 594 : B5 C6                      			ADD		EA, EXTRAM		; add ext ram base
 1164/ 596 : 14                         			CALL	4				; APUSH
 1165/ 597 :                            
 1166/ 597 : C6 01                      GETVA3:		LD		A, @1, P2		; advance to next buffer pos
 1167/ 599 : 19                         GETVA4:		CALL	9				; GETCHR
 1168/ 59A : 3A                         			POP		EA				; return addr
 1169/ 59B : B5 E8                      			ADD		EA, ONE			; skip over error jump
 1170/ 59D : 44                         			LD		PC, EA			; continue in interpreter
 1171/ 59E :                            ;------------------------------------------------------------------------------
 1172/ 59E :                            ; NUMBER	expect a number and push it (call 13)
 1173/ 59E :                            ; call as:
 1174/ 59E :                            ;			CALL 13
 1175/ 59E :                            ;			DB offset to jump to if no number
 1176/ 59E : C2 00                      NUMBER:		LD		A, 0, P2		; get char from buffer
 1177/ 5A0 : 2D E0                      			BND		GETVA1, PC		; if not digit, skip to next loc
 1178/ 5A2 : 85 EA                      			LD		EA, ZERO		; load 0
 1179/ 5A4 : 8D F6                      			ST		EA, TMPF6		; store temporary
 1180/ 5A6 : 09                         NUMBE1:		LD		T, EA			; store into T
 1181/ 5A7 : C6 01                      NUMBE11:	LD		A, @1, P2		; get digit and advance
 1182/ 5A9 : 2D 19                      			BND		NUMBE4, PC		; skip if no more digits
 1183/ 5AB : CD F6                      			ST		A, TMPF6		; store digit    
 1184/ 5AD : 84 0A 00                   			LD		EA, =10			; factor 10
 1185/ 5B0 : 2C                         			MPY		EA, T			; multiply
 1186/ 5B1 : 58                         			OR		A, E			; check overflow?
 1187/ 5B2 : 7C 0E                      			BNZ		NUMBE3			; yes, skip
 1188/ 5B4 : 0B                         			LD		EA, T			; move result to EA
 1189/ 5B5 : B5 F6                      			ADD		EA, TMPF6		; add digit
 1190/ 5B7 : 09                         			LD		T, EA			; store intermediate result
 1191/ 5B8 : 40                         			LD		A, E			; high byte
 1192/ 5B9 : 64 02                      			BP		NUMBE2			; skip if no overflow (became negative)
 1193/ 5BB : 74 05                      			BRA		NUMBE3			; not okay
 1194/ 5BD : 06                         NUMBE2:		LD		A, S			; get status    
 1195/ 5BE : D4 C0                      			AND		A, =0xc0		; mask out OV, CY
 1196/ 5C0 : 6C E5                      			BZ		NUMBE11			; loop unless error
 1197/ 5C2 : 1F                         NUMBE3:		CALL	15				; ERROR
 1198/ 5C3 : 05                         			DB		5				; 5 (value format)
 1199/ 5C4 : C6 FF                      NUMBE4:		LD		A, @-1, P2	; point back to non digit
 1200/ 5C6 : 0B                         			LD		EA, T			; get accumulated value    
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 21 - 2024年05月30日 15時32分15秒


 1201/ 5C7 : 14                         			CALL	4				; APUSH
 1202/ 5C8 : 74 CF                      			BRA		GETVA4			; advance to next position and skip over error offset
 1203/ 5CA :                            ;------------------------------------------------------------------------------
 1204/ 5CA :                            	; intialize interpreter variables
 1205/ 5CA : 84 00 00                   INITAL:		LD		EA, =0x0000		; constant 0
 1206/ 5CD : 8D C3                      			ST		EA, CURRNT		; reset current line number
 1207/ 5CF : 85 C6                      INITA1:		LD		EA, EXTRAM		; get start addr of external RAM
 1208/ 5D1 : B4 34 00                   			ADD		EA, =52			; add offset to next field (26 variables)
 1209/ 5D4 : 8D C8                      			ST		EA, AESTK 		; store start of arithmetic stack
 1210/ 5D6 : B4 1A 00                   			ADD		EA, =26			; add offset to next field
 1211/ 5D9 : 8D CA                      			ST		EA, SBRSTK		; store start of GOSUB stack
 1212/ 5DB : 8D DE                      			ST		EA, SBRPTR		; store pointer to GOSUB level
 1213/ 5DD : B4 10 00                   			ADD		EA, =16			; add offset to next field
 1214/ 5E0 : 8D CC                      			ST		EA, DOSTK		; store start of DO stack
 1215/ 5E2 : 8D DA                      			ST		EA, DOPTR		; store pointer to DO level
 1216/ 5E4 : B4 10 00                   			ADD		EA, =16			; add offset to next field
 1217/ 5E7 : 8D CE                      			ST		EA, FORSTK		; store start of FOR stack
 1218/ 5E9 : 8D DC                      			ST		EA, FORPTR		; store pointer to FOR level
 1219/ 5EB : B4 1C 00                   			ADD		EA, =28			; add offset to next field
 1220/ 5EE : 8D D0                      			ST		EA, BUFAD		; store pointer to line buffer
 1221/ 5F0 : 20 F6 09                   			JSR		INITBD			; initialize baud rate
 1222/ 5F3 :                            									; BUG! ZERO is not yet initialized on first call!
 1223/ 5F3 : C4 34                      			LD		A, =52			; size of variable table in bytes
 1224/ 5F5 : CD F6                      			ST		A, TMPF6		; store it
 1225/ 5F7 : 85 C6                      			LD		EA, EXTRAM		; load RAM BASE into P3
 1226/ 5F9 : 47                         			LD		P3, EA
 1227/ 5FA : 84 00 00                   			LD		EA, =0000		; initialize constant zero
 1228/ 5FD : 8D EA                      			ST		EA, ZERO
 1229/ 5FF : 8D E0                      			ST		EA, INTVEC		; clear vector for current interrupt
 1230/ 601 : 8D E2                      			ST		EA, INTAVC		; clear vector for Interrupt A
 1231/ 603 : 8D E4                      			ST		EA, INTBVC		; clear vector for Interrupt B
 1232/ 605 : 8D C0                      			ST		EA, MULOV
 1233/ 607 : CD E6                      			ST		A, BRKFLG		; enable breaks
 1234/ 609 : C4 00                      INITA2:		LD		A, =00			; clear A
 1235/ 60B : CF 01                      			ST		A, @1, P3		; clear variable area
 1236/ 60D : 9D F6                      			DLD		A, TMPF6		; decrement counter
 1237/ 60F : 7C F8                      			BNZ		INITA2			; until done
 1238/ 611 : C4 01                      			LD		A, =01			; low byte = 01, EA now 0001
 1239/ 613 : 8D E8                      			ST		EA, ONE			; store constant 1
 1240/ 615 : 85 C8                      			LD		EA, AESTK		; load AESTK into P3
 1241/ 617 : 47                         			LD		P3, EA 
 1242/ 618 : C4 52                      			LD		A, ='R'			; store 'R'
 1243/ 61A : CD C5                      			ST		A, RUNMOD
 1244/ 61C : 5C                         			RET						; exit
 1245/ 61D :                            
 1246/ 61D :                            ;------------------------------------------------------------------------------
 1247/ 61D :                            ; CMPTOK (CALL 11) compare current position with token from list in P3
 1248/ 61D :                            ; table is built this way:
 1249/ 61D :                            ;			DB		'token1'
 1250/ 61D :                            ;			DB		jmp displacement OR 0x80
 1251/ 61D :                            ;			DB		'token2'
 1252/ 61D :                            ;			DB		jmp displacement OR 0x80
 1253/ 61D :                            ;			DB		jmp target if not found OR 0x80
 1254/ 61D : 3A                         CMPTOK:		POP		EA				; drop return address
 1255/ 61E : 56                         CMPTO1:		PUSH	P2				; save buffer pointer position
 1256/ 61F : C7 01                      			LD		A, @1, P3		; get byte from table
 1257/ 621 : 64 15                      			BP		CMPTO4			; if positive, belongs to token to match
 1258/ 623 :                            									; negative: matched a complete token
 1259/ 623 : 74 05                      			BRA		CMPTO3			; value is location offset to jump to
 1260/ 625 :                            									; note that the last char in table is negative:
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 22 - 2024年05月30日 15時32分15秒


 1261/ 625 :                            									; the default location always reached if no token matches
 1262/ 625 : C7 01                      CMPTO2:		LD		A, @1, P3		; next char of token from table
 1263/ 627 : 64 0F                      			BP		CMPTO4			; is end of token? yes, found one
 1264/ 629 : 19                         			CALL	9				; GETCHR, read char from buffer
 1265/ 62A :                            									; P2 now points to char after recognized token
 1266/ 62A : 3A                         CMPTO3:		POP		EA				; drop old P2 (start of token)
 1267/ 62B : 85 EA                      			LD		EA, ZERO		; preload a zero
 1268/ 62D : C7 FF                      			LD		A, @-1, P3		; get the location offset
 1269/ 62F : D4 7F                      			AND		A, =0x7f		; discard high bit
 1270/ 631 : 8D F6                      			ST		EA, TMPF6    	; store temporary
 1271/ 633 : 33                         			LD		EA, P3			; get pointer postion
 1272/ 634 : B5 F6                      			ADD		EA, TMPF6    	; add offset
 1273/ 636 : 5F                         			POP		P3				; restore P3
 1274/ 637 : 44                         			LD		PC, EA			; go to location
 1275/ 638 : E6 01                      CMPTO4:		XOR		A, @1, P2		; compare token char with buffer
 1276/ 63A : D4 7F                      			AND		A, =0x7f		; only select 7 bits
 1277/ 63C : 6C E7                      			BZ		CMPTO2			; matches, loop
 1278/ 63E : 5E                         			POP		P2				; does not match, reload buffer pointer
 1279/ 63F : C7 01                      CMPTO5:		LD		A, @1, P3		; get char from table, advance until end of token
 1280/ 641 : 64 FC                      			BP		CMPTO5    		; loop as long token char
 1281/ 643 : 74 D9                      			BRA		CMPTO1			; retry next token from table
 1282/ 645 :                            
 1283/ 645 :                            ;------------------------------------------------------------------------------
 1284/ 645 :                            ; get relational expression (call 0)
 1285/ 645 :                            ; term {<|<=|=|<>|>|>=} term
 1286/ 645 :                            ;
 1287/ 645 :                            ; note the precedence seems to be warped:
 1288/ 645 :                            ; I'd expect something like 
 1289/ 645 :                            ;	X>5 AND X<10 to match an X between 5 and 10,
 1290/ 645 :                            ; but TERM binds the AND operator stronger
 1291/ 645 :                            ; thus it is interpreted as
 1292/ 645 :                            ;   X > (5 AND X) < 10
 1293/ 645 :                            ; which results in an error 3
 1294/ 645 : 20 97 06                   RELEXP:		JSR 	TERM			; get first operand
 1295/ 648 : 23 4C 06                   			PLI		P3, =OPTBL1		; list of comparison operators
 1296/ 64B : 1B                         			CALL	11				; CMPTOK
 1297/ 64C : 3D                         OPTBL1:		DB		'='
 1298/ 64D : 8E                         			DB		0x8e			; to RELEQ
 1299/ 64E : 3C 3D                      			DB		'<='
 1300/ 650 : 90                         			DB		0x90			; to RELLE
 1301/ 651 : 3C 3E                      			DB		'<>'
 1302/ 653 : 92                         			DB		0x92			; to RELNE
 1303/ 654 : 3C                         			DB		'<'
 1304/ 655 : 95                         			DB		0x95			; to RELLT
 1305/ 656 : 3E 3D                      			DB		'>='
 1306/ 658 : 97                         			DB		0x97    		; to RELGE
 1307/ 659 : 3E                         			DB		'>'
 1308/ 65A : 9A                         			DB		0x9a			; to RELGT
 1309/ 65B : A6                         			DB		0xa6			; default case to RELEX3
 1310/ 65C :                            
 1311/ 65C : 13                         RELEQ:		CALL	3				; COMPAR
 1312/ 65D : D4 02                      			AND		A, =0x02		; is equal?
 1313/ 65F : 74 17                      			BRA		RELEX1
 1314/ 661 : 13                         RELLE:		CALL	3				; COMPAR
 1315/ 662 : D4 82                      			AND		A, =0x82		; is less or equal?
 1316/ 664 : 74 12                      			BRA		RELEX1
 1317/ 666 : 13                         RELNE:		CALL	3				; COMPAR
 1318/ 667 : D4 81                      			AND		A, =0x81		; is less or greater?
 1319/ 669 : 74 0D                      			BRA		RELEX1
 1320/ 66B : 13                         RELLT:		CALL	3				; COMPAR
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 23 - 2024年05月30日 15時32分15秒


 1321/ 66C : D4 80                      			AND		A, =0x80		; is less?
 1322/ 66E : 74 08                      			BRA		RELEX1
 1323/ 670 : 13                         RELGE:		CALL	3				; COMPAR
 1324/ 671 : D4 03                      			AND		A, =0x03		; is greater or equal?
 1325/ 673 : 74 03                      			BRA		RELEX1
 1326/ 675 : 13                         RELGT:		CALL	3				; COMPAR
 1327/ 676 : D4 01                      			AND		A, =0x01		; is greater?
 1328/ 678 : 6C 05                      RELEX1:		BZ		RELEX2			; condition not matched
 1329/ 67A : 84 FF FF                   			LD		EA, =0xffff		; return -1 (condition matched)
 1330/ 67D : 14                         			CALL	4				; APUSH
 1331/ 67E : 5C                         			RET
 1332/ 67F : 85 EA                      RELEX2:		LD		EA, ZERO		; return 0 (condition not matched)
 1333/ 681 : 14                         			CALL	4				; APUSH
 1334/ 682 : 5C                         RELEX3:		RET
 1335/ 683 :                            
 1336/ 683 :                            ;------------------------------------------------------------------------------
 1337/ 683 :                            ; COMPAR	(call 3)
 1338/ 683 :                            ; get a second operand and compare it to the first one on STACK
 1339/ 683 : 20 97 06                   COMPAR:		JSR		TERM			; get second operand
 1340/ 686 : 12                         			CALL	2				; SAVOP
 1341/ 687 : BD F6                      			SUB		EA, TMPF6		; compute 1stOP - 2ndOP
 1342/ 689 : 01                         			XCH		A, E			; highbyte
 1343/ 68A : 64 03                      			BP		COMPA1			; positive, i.e. 1st >= 2nd ?
 1344/ 68C : C4 80                      			LD		A, =0x80		; no, set bit 7 (less)
 1345/ 68E : 5C                         			RET
 1346/ 68F : 58                         COMPA1:		OR		A, E			; even zero, i.e. 1st = 2nd ?
 1347/ 690 : 6C 03                      			BZ		COMPA2			; yes
 1348/ 692 : C4 01                      			LD		A, =0x01		; no, set bit 0 (greater)
 1349/ 694 : 5C                         			RET
 1350/ 695 : C4 02                      COMPA2: 	LD		A, =0x02		; set bit 1 (equal)
 1351/ 697 : 5C                         			RET
 1352/ 698 :                            
 1353/ 698 :                            ;------------------------------------------------------------------------------
 1354/ 698 :                            ; evaluate a TERM:   {+|-} factor {+|-} factor
 1355/ 698 : 1C                         TERM:		CALL	12				; EXPECT an optional minus symbol
 1356/ 699 : 2D                         			DB		'-'				; 
 1357/ 69A : 09                         			DB		9				; if not found, skip to TERM2
 1358/ 69B : 20 D0 06                   			JSR		MDTERM			; get first mul/div term
 1359/ 69E : 15                         			CALL	5				; APULL into EA
 1360/ 69F : 1A                         			CALL	10				; NEGATE negate
 1361/ 6A0 : 14                         TERM1:		CALL	4				; APUSH again on stack
 1362/ 6A1 : 74 06                      			BRA		TERM4			; continue
 1363/ 6A3 : 1C                         TERM2:		CALL	12				; EXPECT an optional plus symbol
 1364/ 6A4 : 2B                         			DB		'+'				;
 1365/ 6A5 : 01                         			DB		1				; if not found, continue at TERM3
 1366/ 6A6 : 20 D0 06                   TERM3:		JSR		MDTERM			; get a mul/div term
 1367/ 6A9 : 23 AD 06                   TERM4:		PLI		P3, =CMDT11		; load add/sub/or operator table
 1368/ 6AC : 1B                         			CALL	11				; CMPTOK
 1369/ 6AD :                            CMDT11:
 1370/ 6AD : 2B                         			DB		'+'
 1371/ 6AE : 86                         			DB		0x86			; to TERM5
 1372/ 6AF : 2D                         			DB		'-'
 1373/ 6B0 : 8C                         			DB		0x8c			; to TERM6
 1374/ 6B1 : 4F 52                      			DB		'OR'
 1375/ 6B3 : 91                         			DB		0x91			; to TERM7
 1376/ 6B4 : C5                         			DB		0xc5			; default to FACTOR1 (RET)
 1377/ 6B5 :                            ; process MDTERM + MDTERM
 1378/ 6B5 : 20 D0 06                   TERM5:		JSR		MDTERM			; get second mul/div term
 1379/ 6B8 : 12                         			CALL	2				; SAVOP
 1380/ 6B9 : B5 F6                      			ADD		EA, TMPF6		; compute sum
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 24 - 2024年05月30日 15時32分15秒


 1381/ 6BB : 74 E3                      			BRA		TERM1			; loop for further term of this precedence
 1382/ 6BD :                            ; process MDTERM - MDTERM
 1383/ 6BD : 20 D0 06                   TERM6:		JSR		MDTERM			; get second mul/div term
 1384/ 6C0 : 12                         			CALL	2				; SAVOP
 1385/ 6C1 : BD F6                      			SUB		EA, TMPF6		; compute difference
 1386/ 6C3 : 74 DB                      			BRA		TERM1			; loop for further term of this precedence
 1387/ 6C5 :                            ; process MDTERM OR MDTERM
 1388/ 6C5 : 20 D0 06                   TERM7:		JSR		MDTERM			; get second operand
 1389/ 6C8 : 12                         			CALL	2				; SAVOP
 1390/ 6C9 : DD F6                      			OR		A, TMPF6		; do byte by byte OR
 1391/ 6CB : 01                         			XCH		A, E
 1392/ 6CC : DD F7                      			OR		A, TMPF6+1
 1393/ 6CE : 01                         			XCH		A, E
 1394/ 6CF : 74 CF                      			BRA		TERM1			; loop for further term of this precedence
 1395/ 6D1 :                            
 1396/ 6D1 :                            ;------------------------------------------------------------------------------
 1397/ 6D1 :                            ; evaluate multiplicative term		factor {*|/} factor
 1398/ 6D1 : 11                         MDTERM:		CALL	1				; FACTOR get first factor
 1399/ 6D2 : 23 D6 06                   MDTER0:		PLI		P3, =CMDT13		; load table of mul/div/and operators
 1400/ 6D5 : 1B                         			CALL	11				; CMPTOK
 1401/ 6D6 : 2A                         CMDT13:		DB		'*'
 1402/ 6D7 : 87                         			DB		0x87			; to MDTER1
 1403/ 6D8 : 2F                         			DB		'/'
 1404/ 6D9 : 8D                         			DB		0x8d			; to MDTER3
 1405/ 6DA : 41 4E 44                   			DB		'AND'
 1406/ 6DD : 90                         			DB		0x90			; to MDTER4
 1407/ 6DE : 9B                         			DB		0x9b			; default to FACTO1 (return)
 1408/ 6DF :                            
 1409/ 6DF :                            ; process	FACTOR * FACTOR
 1410/ 6DF : 11                         MDTER1:		CALL	1				; FACTOR get 2nd operand
 1411/ 6E0 : 12                         			CALL	2				; SAVOP
 1412/ 6E1 : 20 FD 07                   			JSR		MULTOP			; multiply EA * TMPF6
 1413/ 6E4 : 14                         MDTER2:		CALL	4				; APUSH push result on stack
 1414/ 6E5 : 74 EB                      			BRA		MDTER0			; loop for further multiplicative term
 1415/ 6E7 :                            ; process FACTOR / FACTOR (handle division by zero in subroutine)
 1416/ 6E7 : 11                         MDTER3:		CALL	1				; FACTOR get 2nd operand
 1417/ 6E8 : 12                         			CALL	2				; SAVOP
 1418/ 6E9 : 20 15 08                   			JSR		DIVOP			; divide EA / TMPF6
 1419/ 6EC : 74 F6                      			BRA		MDTER2			; loop for further multiplicative term
 1420/ 6EE :                            ; process FACTOR AND FACTOR
 1421/ 6EE : 11                         MDTER4:		CALL	1				; FACTOR get 2nd operand
 1422/ 6EF : 12                         			CALL	2				; SAVOP
 1423/ 6F0 : D5 F6                      			AND		A, TMPF6		; do byte by byte AND
 1424/ 6F2 : 01                         			XCH		A, E
 1425/ 6F3 : D5 F7                      			AND		A, TMPF6+1
 1426/ 6F5 : 01                         			XCH		A, E
 1427/ 6F6 : 74 EC                      			BRA		MDTER2			; loop for further multiplicative term
 1428/ 6F8 :                            
 1429/ 6F8 :                            ;------------------------------------------------------------------------------
 1430/ 6F8 :                            ; FACTOR	(call 1) get a factor: number, var, function, (RELEXP)
 1431/ 6F8 : 1D                         FACTOR:		CALL	13				; NUMBER get number in sequence
 1432/ 6F9 : 02                         			DB		2				; if not found continue at FACTO2
 1433/ 6FA : 5C                         FACTO1:		RET						; has numeric operand on stack, done
 1434/ 6FB :                            
 1435/ 6FB : 23 FF 06                   FACTO2:		PLI		P3, =CMDT12		; load table of standard functions
 1436/ 6FE : 1B                         			CALL	11				; CMPTOK
 1437/ 6FF :                            CMDT12:
 1438/ 6FF : 28                         			DB		'('				; left parenthesis (subexpression)
 1439/ 700 : B2                         			DB		0xb2			; to LPAREN
 1440/ 701 : 40                         			DB		'@'				; right hand side @
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 25 - 2024年05月30日 15時32分15秒


 1441/ 702 : B7                         			DB		0xb7			; to ATRH
 1442/ 703 : 23                         			DB		'#'				; hex operator
 1443/ 704 : E5                         			DB		0xe5			; to HASHFN
 1444/ 705 : 4E 4F 54                   			DB		'NOT'			; NOT operator
 1445/ 708 : B7                         			DB		0xb7			; to NOTFN
 1446/ 709 : 53 54 41 54                			DB		'STAT'			; right hand side STAT
 1447/ 70D : BC                         			DB		0xbc			; to STATRH
 1448/ 70E : 54 4F 50                   			DB		'TOP'			; right hand side TOP
 1449/ 711 : BB                         			DB		0xbb			; to TOPFN
 1450/ 712 : 49 4E 43                   			DB		'INC'			; INC(X) function
 1451/ 715 : BD                         			DB		0xbd			; to INCFN
 1452/ 716 : 44 45 43                   			DB		'DEC'			; DEC(X) function
 1453/ 719 : C2                         			DB		0xc2			; to DECFN
 1454/ 71A : 4D 4F 44                   			DB		'MOD'			; MOD(X,Y) function
 1455/ 71D : CE                         			DB		0xce			; to MODFN
 1456/ 71E : 52 4E 44                   			DB		'RND'			; RND(X,Y) function
 1457/ 721 : E5                         			DB		0xe5			; to RNDFN
 1458/ 722 : 80                         			DB		0x80			; default to FACTO3 (variable)
 1459/ 723 : 20 75 05                   FACTO3:		JSR		GETVAR
 1460/ 726 : 12                         			DB		0x12			; if not var, goto SNERR3
 1461/ 727 : 20 2B 07                   			JSR		PEEK
 1462/ 72A : 14                         			CALL	4				; APUSH
 1463/ 72B : 5C                         			RET
 1464/ 72C :                            
 1465/ 72C :                            ;------------------------------------------------------------------------------
 1466/ 72C :                            ; peek word at address on stack
 1467/ 72C : 15                         PEEK:		CALL	5				; APULL
 1468/ 72D : 57                         			PUSH	P3
 1469/ 72E : 47                         			LD		P3, EA
 1470/ 72F : 83 00                      			LD		EA, 0, P3
 1471/ 731 : 5F                         			POP		P3
 1472/ 732 : 5C                         			RET
 1473/ 733 :                            
 1474/ 733 :                            ;------------------------------------------------------------------------------
 1475/ 733 :                            ; handle parenthesized expression '(' expr ')'
 1476/ 733 : 10                         LPAREN:		CALL	0				; RELEXP get expression
 1477/ 734 : 1C                         			CALL	12				; EXPECT a closing parenthesis
 1478/ 735 : 29                         			DB		')'
 1479/ 736 : 02                         			DB		0x02			; if not found, goto SNERR3
 1480/ 737 : 5C                         			RET
 1481/ 738 :                            
 1482/ 738 :                            ;------------------------------------------------------------------------------
 1483/ 738 : 1F                         SNERR3:		CALL	15				; ERROR
 1484/ 739 : 04                         			DB		4				; 4 (syntax error)
 1485/ 73A :                            
 1486/ 73A :                            ;------------------------------------------------------------------------------
 1487/ 73A :                            ; @ operator
 1488/ 73A : 11                         ATRH:		CALL	1				; FACTOR get the address to peek
 1489/ 73B : 20 2B 07                   			JSR		PEEK			; read memory
 1490/ 73E : 74 24                      			BRA		DECFN2			; make 16 bit result on stack
 1491/ 740 :                            
 1492/ 740 :                            ;------------------------------------------------------------------------------
 1493/ 740 :                            ; NOT operator
 1494/ 740 : 11                         NOTFN:		CALL	1				; FACTOR get argument
 1495/ 741 : 15                         			CALL	5				; APULL into EA
 1496/ 742 : E4 FF                      			XOR		A, =0xff		; do byte by byte complement
 1497/ 744 : 01                         			XCH		A, E
 1498/ 745 : E4 FF                      			XOR		A, =0xff
 1499/ 747 : 01                         			XCH		A, E
 1500/ 748 : 14                         			CALL	4				; APUSH result on stack
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 26 - 2024年05月30日 15時32分15秒


 1501/ 749 : 5C                         			RET
 1502/ 74A :                            
 1503/ 74A :                            ;------------------------------------------------------------------------------
 1504/ 74A :                            ; STAT function
 1505/ 74A : 06                         STATRH:		LD		A, S			; get the current status reg
 1506/ 74B : 74 17                      			BRA		DECFN2			; make 16 bit result on stack
 1507/ 74D :                            
 1508/ 74D :                            ;------------------------------------------------------------------------------
 1509/ 74D :                            ; TOP function
 1510/ 74D : 85 D6                      TOPFN:		LD		EA, TXTUNF		; get current top of program area
 1511/ 74F : B5 E8                      			ADD		EA, ONE			; add 1 to return next free location
 1512/ 751 : 14                         			CALL	4				; APUSH	push on stack
 1513/ 752 : 5C                         			RET
 1514/ 753 :                            
 1515/ 753 :                            ;------------------------------------------------------------------------------
 1516/ 753 :                            ; INC function
 1517/ 753 : 20 AB 07                   INCFN:		JSR		ARGONE			; get a single function arg into EA
 1518/ 756 : 56                         			PUSH	P2				;   save P2
 1519/ 757 : 46                         			LD		P2, EA			; put as address into P2
 1520/ 758 : 92 00                      			ILD		A, 0, P2		; increment this cell
 1521/ 75A : 74 07                      			BRA		DECFN1			; return the new result as 16 bit
 1522/ 75C :                            
 1523/ 75C :                            ;------------------------------------------------------------------------------
 1524/ 75C :                            ; DEC function
 1525/ 75C : 20 AB 07                   DECFN:		JSR		ARGONE			; get a single function arg into EA
 1526/ 75F : 56                         			PUSH	P2				;   save P2
 1527/ 760 : 46                         			LD		P2, EA			; put as address into P2
 1528/ 761 : 9A 00                      			DLD		A, 0, P2		; decrement this cell
 1529/ 763 : 5E                         DECFN1:		POP		P2				;   restore old P2
 1530/ 764 : 01                         DECFN2:		XCH		A, E			; save result
 1531/ 765 : C4 00                      			LD		A, =0x00		; make zero high byte
 1532/ 767 : 01                         			XCH		A, E			; restore result as low byte
 1533/ 768 : 14                         			CALL	4				; APUSH 16 bit result on stack
 1534/ 769 : 5C                         			RET
 1535/ 76A :                            
 1536/ 76A :                            ;------------------------------------------------------------------------------
 1537/ 76A :                            ; jump to # operator
 1538/ 76A : 74 57                      HASHFN:		BRA		HASHF0			; forward to HEX number interpreter
 1539/ 76C :                            
 1540/ 76C :                            ;------------------------------------------------------------------------------
 1541/ 76C :                            ; MOD function
 1542/ 76C : 20 B4 07                   MODFN:		JSR		ARGTWO			; get two arguments
 1543/ 76F : 12                         			CALL	2				; SAVOP: 1st arg=EA, 2nd=TMPF6
 1544/ 770 : 09                         MODFN1:		LD		T, EA			; T = 1st arg
 1545/ 771 : 85 F6                      			LD		EA, TMPF6		; EA = 2nd arg
 1546/ 773 : 8D FE                      			ST		EA, TMPFE		; save in temp
 1547/ 775 : 0B                         			LD		EA, T			; save 1nd arg in TMPFC
 1548/ 776 : 8D FC                      			ST		EA, TMPFC
 1549/ 778 : 20 15 08                   			JSR		DIVOP			; divide EA / TMPF6
 1550/ 77B : 8D F6                      			ST		EA, TMPF6		; quotient into TMPF6
 1551/ 77D : 85 FE                      			LD		EA, TMPFE		; multiply with 2nd arg
 1552/ 77F : 20 FD 07                   			JSR		MULTOP			; i.e. EA div F6 * F6
 1553/ 782 : 1A                         			CALL	10				; NEGATE, i.e. -(EA div F6 * F6)
 1554/ 783 : B5 FC                      			ADD		EA, TMPFC		; subtract from 1st: EA - (EA div F6 * F6)
 1555/ 785 : 14                         			CALL	4				; APUSH on stack
 1556/ 786 : 5C                         			RET
 1557/ 787 :                            
 1558/ 787 :                            ;------------------------------------------------------------------------------
 1559/ 787 :                            ; RND function
 1560/ 787 : 20 B4 07                   RNDFN:		JSR		ARGTWO			; get two arguments on stack
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 27 - 2024年05月30日 15時32分15秒


 1561/ 78A : A5 F4                      			LD		T, RNDNUM		; get random number
 1562/ 78C : 84 85 04                   			LD		EA, =0x0485		; multiply with 1157
 1563/ 78F : 2C                         			MPY		EA, T
 1564/ 790 : 0B                         			LD		EA, T			; use only low 16 bits
 1565/ 791 : B4 19 36                   			ADD		EA, =0x3619		; add 13849
 1566/ 794 : 8D F4                      			ST		EA, RNDNUM		; discard overflow and save as new random value
 1567/ 796 : 15                         			CALL	5				; APULL second arg
 1568/ 797 : B5 E8                      			ADD		EA, ONE			; add one
 1569/ 799 : BB FE                      			SUB		EA, -2, P3		; subtract 1st arg
 1570/ 79B : 8D F6                      			ST		EA, TMPF6		; save as TMPF6
 1571/ 79D : 85 F4                      			LD		EA, RNDNUM		; get random value
 1572/ 79F : 01                         			XCH		A, E			; make random number positive
 1573/ 7A0 : D4 7F                      			AND		A, =0x7f
 1574/ 7A2 : 01                         			XCH		A, E
 1575/ 7A3 : 20 6F 07                   			JSR		MODFN1			; MOD(random, (2nd-1st+1))
 1576/ 7A6 : 15                         			CALL	5				; APULL get result
 1577/ 7A7 : B3 FE                      			ADD		EA, -2, P3		; add 1st arg
 1578/ 7A9 : 8B FE                      			ST		EA, -2, P3		; store inplace on stack
 1579/ 7AB : 5C                         			RET
 1580/ 7AC :                            
 1581/ 7AC :                            ;------------------------------------------------------------------------------
 1582/ 7AC :                            ; get a single function argument
 1583/ 7AC : 1C                         ARGONE:		CALL	12				; EXPECT opening paren
 1584/ 7AD : 28                         			DB		'('
 1585/ 7AE : 13                         			DB		0x13			; if not found, goto SNERR4
 1586/ 7AF : 10                         			CALL	0				; RELEXP expression
 1587/ 7B0 : 1C                         			CALL	12				; EXPECT closing paren
 1588/ 7B1 : 29                         			DB		')'
 1589/ 7B2 : 0F                         			DB		0x0f			; if not found, goto SNERR4
 1590/ 7B3 : 15                         			CALL	5				; APULL argument into EA
 1591/ 7B4 : 5C                         			RET
 1592/ 7B5 :                            
 1593/ 7B5 :                            ;------------------------------------------------------------------------------
 1594/ 7B5 :                            ; get a double function arg
 1595/ 7B5 : 1C                         ARGTWO:		CALL	12				; EXPECT opening paren
 1596/ 7B6 : 28                         			DB		'('
 1597/ 7B7 : 0A                         			DB		0x0a			; if not found goto SNERR4
 1598/ 7B8 : 10                         			CALL	0				; RELEXP get first arg on stack
 1599/ 7B9 : 1C                         			CALL	12				; EXPECT a comma
 1600/ 7BA : 2C                         			DB		','
 1601/ 7BB : 06                         			DB		0x06			; if not found, goto SNERR4
 1602/ 7BC : 10                         			CALL	0				; RELEXP get 2nd arg on stack
 1603/ 7BD : 1C                         			CALL	12				; EXPECT closing paren
 1604/ 7BE : 29                         			DB		')'
 1605/ 7BF : 02                         			DB		0x02			; if not found, goto SNERR4
 1606/ 7C0 : 5C                         			RET						; leaves 2 args on stack
 1607/ 7C1 :                            
 1608/ 7C1 : 1F                         SNERR4:		CALL	15				; ERROR
 1609/ 7C2 : 04                         			DB		4				; 4 (syntax error)
 1610/ 7C3 :                            
 1611/ 7C3 :                            ;------------------------------------------------------------------------------
 1612/ 7C3 :                            ; # operator
 1613/ 7C3 :                            ; handle hexadecimal constants
 1614/ 7C3 : 85 EA                      HASHF0:		LD		EA, ZERO		; initialize temporary
 1615/ 7C5 : 8D F6                      			ST		EA, TMPF6
 1616/ 7C7 : 09                         			LD		T, EA			; also clear T (collects value)
 1617/ 7C8 : C6 01                      			LD		A, @1, P2		; get first digit
 1618/ 7CA : 2D 02                      			BND		HASHF1, PC		; if not digit, skip
 1619/ 7CC : 74 1A                      			BRA		HASHF5			; handle decimal digit (0..9)
 1620/ 7CE : 20 F3 07                   HASHF1:		JSR		CVTHEX			; may be 'A'..'F', convert to 0..5
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 28 - 2024年05月30日 15時32分15秒


 1621/ 7D1 : 64 13                      			BP		HASHF4			; if negative, was no hex letter
 1622/ 7D3 : 1F                         			CALL	15				; ERROR
 1623/ 7D4 : 05                         			DB		5				; 5 (value error)
 1624/ 7D5 :                            
 1625/ 7D5 : C6 01                      HASHF2:		LD		A, @1, P2		; get next char from number
 1626/ 7D7 : 2D 02                      			BND		HASHF3, PC		; if not digit, skip
 1627/ 7D9 : 74 0D                      			BRA		HASHF5			; insert next digit
 1628/ 7DB : 20 F3 07                   HASHF3:		JSR		CVTHEX			; may by 'A'..'F', convert to 0..5
 1629/ 7DE : 64 06                      			BP		HASHF4			; if a letter, insert it
 1630/ 7E0 : 0B                         			LD		EA, T			; done with hex number, put value into EA
 1631/ 7E1 : 14                         			CALL	4				; APUSH on stack
 1632/ 7E2 : C6 FF                      			LD		A, @-1, P2		; re-get the last non-hex char
 1633/ 7E4 : 19                         			CALL	9				; GETCHR
 1634/ 7E5 : 5C                         			RET						; done
 1635/ 7E6 : F4 0A                      HASHF4:		ADD		A, =0x0a		; cvt hex 'letter' into range 10..15
 1636/ 7E8 : CD F6                      HASHF5:		ST		A, TMPF6		; store digit temporary (0..15)
 1637/ 7EA : 0B                         			LD		EA, T			; shift 4 bit left
 1638/ 7EB : 0F                         			SL		EA
 1639/ 7EC : 0F                         			SL		EA
 1640/ 7ED : 0F                         			SL		EA
 1641/ 7EE : 0F                         			SL		EA
 1642/ 7EF : B5 F6                      			ADD		EA, TMPF6		; add digit
 1643/ 7F1 : 09                         			LD		T, EA			; put back into T
 1644/ 7F2 : 74 E1                      			BRA		HASHF2			; loop
 1645/ 7F4 :                            
 1646/ 7F4 :                            ;------------------------------------------------------------------------------
 1647/ 7F4 :                            ; convert an ASCII hex digit to 0x00...0x05
 1648/ 7F4 : FC 47                      CVTHEX:		SUB		A, =0x47		; subtract 'G'
 1649/ 7F6 : 64 03                      			BP		CVTHE1			; is >= 'G', yes, return -1
 1650/ 7F8 : F4 06                      			ADD		A, =0x06		; adjust into range 0..5 if 'A'..'F'
 1651/ 7FA : 5C                         			RET						; still negative, if < 'A'
 1652/ 7FB : C4 FF                      CVTHE1:		LD		A, =0xff		; return negative result
 1653/ 7FD : 5C                         			RET
 1654/ 7FE :                            
 1655/ 7FE :                            ;------------------------------------------------------------------------------
 1656/ 7FE :                            ; Multiply EA * TMPF6 -> EA
 1657/ 7FE : 20 27 08                   MULTOP:		JSR		GETSGN			; make operands positive, and save result sign in FB
 1658/ 801 : A5 F6                      			LD		T, TMPF6		; compute EA * F6
 1659/ 803 : 2C                         			MPY		EA, T
 1660/ 804 : 8D C0                      			ST		EA, MULOV		; save higher result as overflow
 1661/ 806 : C5 FB                      MULTO1:		LD		A, TMPFB		; get resulting sign
 1662/ 808 : 64 0A                      			BP		NEGAT1			; if positive, return result unchanged
 1663/ 80A : 0B                         			LD		EA, T    		; otherwise put result in EA
 1664/ 80B :                            									; and fall through into NEGATE
 1665/ 80B :                            
 1666/ 80B :                            ;--------------------------------------------------------------------------------------------------
 1667/ 80B :                            ; negate number in EA (call 10)
 1668/ 80B : E4 FF                      NEGATE:		XOR		A, =0xff		; 1's complement low byte
 1669/ 80D : 01                         			XCH		A, E			; swap
 1670/ 80E : E4 FF                      			XOR		A, =0xff		; 1's complement high byte
 1671/ 810 : 01                         			XCH		A, E    		; swap back
 1672/ 811 : B5 E8                      			ADD		EA, ONE			; add ONE (2's complement)
 1673/ 813 : 5C                         			RET
 1674/ 814 :                            
 1675/ 814 : 0B                         NEGAT1:		LD		EA, T			; return positive result
 1676/ 815 : 5C                         			RET
 1677/ 816 :                            
 1678/ 816 :                            ;------------------------------------------------------------------------------
 1679/ 816 :                            ; divide EA / TMPF6 -> EA
 1680/ 816 : 20 27 08                   DIVOP:		JSR		GETSGN			; make operands positive, save result sign in FB
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 29 - 2024年05月30日 15時32分15秒


 1681/ 819 : 09                         			LD		T, EA			; 1st arg in T
 1682/ 81A : 85 F6                      			LD		EA, TMPF6		; check 2nd arg
 1683/ 81C : 58                         			OR		A, E			; is it zero?
 1684/ 81D : 6C 07                      			BZ		DV0ERR			; yes, division by zero error
 1685/ 81F : 0B                         			LD		EA, T			; EA = 1st arg
 1686/ 820 : A5 F6                      			LD		T, TMPF6		; T = 2nd arg
 1687/ 822 : 0D                         			DIV		EA, T			; divide
 1688/ 823 : 09                         			LD		T, EA			; store quotient into T
 1689/ 824 : 74 E0                      			BRA		MULTO1			; adjust result sign
 1690/ 826 :                            
 1691/ 826 : 1F                         DV0ERR:		CALL	15				; ERROR    
 1692/ 827 : 0C                         			DB		0x0c			; 12 (div by zero)
 1693/ 828 :                            
 1694/ 828 :                            ;------------------------------------------------------------------------------
 1695/ 828 :                            ; make operands of Mul/Div positive, and store result sign in TMPFB
 1696/ 828 : 09                         GETSGN:		LD		T, EA			; 1st arg into T
 1697/ 829 : C5 F7                      			LD		A, TMPF6+1		; get sign of 2nd arg
 1698/ 82B : CD FB                      			ST		A, TMPFB		; store in FB
 1699/ 82D : 64 05                      			BP		GETSG1			; was positive, skip
 1700/ 82F : 85 F6                      			LD		EA, TMPF6		; negate 2nd arg
 1701/ 831 : 1A                         			CALL	10				; NEGATE
 1702/ 832 : 8D F6                      			ST		EA, TMPF6		; store it back
 1703/ 834 : 0B                         GETSG1:		LD		EA, T			; get 1st arg
 1704/ 835 : 40                         			LD		A, E			; get sign
 1705/ 836 : E5 FB                      			XOR		A, TMPFB		; exor with sign of 2nd
 1706/ 838 : CD FB                      			ST		A, TMPFB		; save as resulting sign
 1707/ 83A : 0B                         			LD		EA, T			; get 1st arg
 1708/ 83B : 01                         			XCH		A, E			; get sign
 1709/ 83C : 64 03                      			BP		GETSG2			; was positive, restore and exit
 1710/ 83E : 01                         			XCH		A, E			; otherwise negate 1nd arg 
 1711/ 83F : 1A                         			CALL	10				; NEGATE
 1712/ 840 : 5C                         			RET			
 1713/ 841 : 01                         GETSG2:		XCH		A, E			; return 1st arg in EA
 1714/ 842 : 5C                         			RET
 1715/ 843 :                            
 1716/ 843 :                            ;----------------------------------------------------------------------------------------------
 1717/ 843 :                            ; push a value in EA onto AESTK, pointed to by P3
 1718/ 843 : 08                         APUSH:		PUSH	EA				; save value
 1719/ 844 : 33                         			LD		EA, P3			; get P3 value
 1720/ 845 : BD CA                      			SUB		EA, SBRSTK		; subtract end of AESTK (= start of SBRSTK)
 1721/ 847 : 01                         			XCH		A, E			; get high byte
 1722/ 848 : 64 04                      			BP		APUSH1			; negative?, yes error
 1723/ 84A : 3A                         			POP		EA				; restore value
 1724/ 84B : 8F 02                      			ST		EA, @2, P3		; store in stack, pointed to by P3, autoincrement
 1725/ 84D : 5C                         			RET
 1726/ 84E : 1F                         APUSH1:		CALL 	15				; error 9 (stack overflow)
 1727/ 84F : 09                         			DB		9				; error code
 1728/ 850 :                            
 1729/ 850 :                            ;----------------------------------------------------------------------------------------------
 1730/ 850 :                            ; SAVOP		(call 2) pull last op and save into TMPF6, then pull 2nd last into EA
 1731/ 850 : 15                         SAVOP:		CALL	5				; APULL
 1732/ 851 : 8D F6                      			ST 		EA, TMPF6		; save last value
 1733/ 853 :                            
 1734/ 853 :                            ;--------------------------------------------------------------------------------------------------
 1735/ 853 :                            ; pull a value off AESTK pointed to by P3, return in EA (call 5)
 1736/ 853 : 87 FE                      APULL:		LD		EA, @-2, P3		; get value from stack, autodecrement
 1737/ 855 : 5C                         			RET						; return
 1738/ 856 :                            
 1739/ 856 :                            ;--------------------------------------------------------------------------------------------------
 1740/ 856 :                            ; get a line into BUFAD, return P2 = BUFAD
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 30 - 2024年05月30日 15時32分15秒


 1741/ 856 : 85 D0                      GETLN:		LD		EA, BUFAD		; set P2 = BUFAD
 1742/ 858 : 46                         			LD		P2, EA			; 
 1743/ 859 : C4 00                      			LD		A, =0			; clear BUFCNT
 1744/ 85B : CD FE                      			ST		A, TMPFE
 1745/ 85D : C5 C2                      			LD		A, INPMOD    	; input mode
 1746/ 85F : 6C 07                      			BZ		GETLN1			; if zero, do '>' prompt
 1747/ 861 : C4 3F                      			LD		A, =QUEST		; load '?'
 1748/ 863 : 17                         			CALL 	7				; PUTC
 1749/ 864 : C4 20                      			LD		A, =SPACE		; load space
 1750/ 866 : 74 02                      			BRA		GETLN2			; continue
 1751/ 868 : C4 3E                      GETLN1:		LD		A, =GTR			; load '>'
 1752/ 86A : 17                         GETLN2:		CALL 	7				; PUTC
 1753/ 86B : 20 33 09                   GETCH:		JSR		GECO			; get char with echo in A
 1754/ 86E : 6C FB                      			BZ		GETCH			; if zero, ignore
 1755/ 870 : 48                         			LD		E, A			; save char into E
 1756/ 871 : E4 0A                      			XOR		A, =LF			; is it LF?
 1757/ 873 : 6C F6                      			BZ		GETCH			; yes, ignore
 1758/ 875 : E4 07                      			XOR		A, =0x07		; is it CR?		A xor (0a xor 07)
 1759/ 877 : 6C 3F                      			BZ		EOLN			; yes, skip
 1760/ 879 : E4 52                      			XOR		A, =0x52		; is it '_'?	A xor (0d xor 52)
 1761/ 87B : 6C 25                      			BZ		DELCH			; yes skip
 1762/ 87D : E4 57                      			XOR		A, =0x57		; is it 0x08?	A xor (5f xor 57)
 1763/ 87F : 6C 1B                      			BZ		CTRLH			; yes skip
 1764/ 881 : E4 1D                      			XOR		A, =0x1d		; is it 0x15?	A xor (08 xor 1d)
 1765/ 883 : 6C 0E                      			BZ		CTRLU			; yes skip
 1766/ 885 : E4 16                      			XOR		A, =0x16		; is it 0x03?	A xor (15 xor 16)
 1767/ 887 : 7C 23                      			BNZ		CHAR			; no, skip: no control char
 1768/ 889 : C4 5E                      			LD		A, =CARET		; load '^'
 1769/ 88B : 17                         			CALL	7				; PUTC
 1770/ 88C : C4 43                      			LD		A, ='C'			; load 'C'
 1771/ 88E : 17                         			CALL 	7				; PUTC
 1772/ 88F : 18                         			CALL	8				; CRLF
 1773/ 890 : 24 A2 00                   			JMP		MAINLP			; back to interpreter
 1774/ 893 : C4 5E                      CTRLU:		LD		A, =CARET		; load '^'
 1775/ 895 : 17                         			CALL 	7				; PUTC
 1776/ 896 : C4 55                      			LD		A, ='U'			; load 'U'
 1777/ 898 : 17                         			CALL	7				; PUTC
 1778/ 899 : 18                         			CALL	8				; CRLF
 1779/ 89A : 74 BA                      			BRA		GETLN			; restart input line
 1780/ 89C : C4 20                      CTRLH:		LD		A, =SPACE		; load ' '
 1781/ 89E : 17                         			CALL	7				; PUTC
 1782/ 89F : C4 08                      			LD		A, =BS			; load backspace
 1783/ 8A1 : 17                         			CALL 	7				; PUTC
 1784/ 8A2 : C5 FE                      DELCH:		LD		A, TMPFE		; load buffer count
 1785/ 8A4 : 6C C5                      			BZ		GETCH			; if at beginning of line, loop
 1786/ 8A6 : 9D FE                      			DLD		A, TMPFE		; decrement buffer count
 1787/ 8A8 : C6 FF                      			LD		A, @-1, P2    	; point one buffer pos back
 1788/ 8AA : 74 BF                      			BRA		GETCH			; loop 
 1789/ 8AC : 40                         CHAR:		LD		A, E			; get char back
 1790/ 8AD : CE 01                      			ST		A, @1, P2   	; put into buffer
 1791/ 8AF : 95 FE                      			ILD		A, TMPFE		; increment buffer counter
 1792/ 8B1 : E4 49                      			XOR		A, =73			; limit of 72 chars reached?
 1793/ 8B3 : 7C B6                      			BNZ		GETCH			; no get another
 1794/ 8B5 : C4 0D                      			LD		A, =CR			; load CR
 1795/ 8B7 : 17                         			CALL	7				; emit
 1796/ 8B8 :                            
 1797/ 8B8 : C4 0D                      EOLN:		LD		A, =CR			; load CR
 1798/ 8BA : CE 01                      			ST		A, @1, P2		; put into buffer
 1799/ 8BC : C4 0A                      			LD		A, =LF			; load LF
 1800/ 8BE : 17                         			CALL	7				; PUTC
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 31 - 2024年05月30日 15時32分15秒


 1801/ 8BF : 85 D0                      			LD		EA, BUFAD		; get BUFAD into P2
 1802/ 8C1 : 46                         			LD		P2, EA
 1803/ 8C2 : 5C                         			RET						; done
 1804/ 8C3 :                            
 1805/ 8C3 :                            ;--------------------------------------------------------------------------------------------------
 1806/ 8C3 :                            ; handle Interrupt A (will only happen with external I/O, otherwise SA is in use)
 1807/ 8C3 : 08                         INTA:		PUSH	EA				; save EA
 1808/ 8C4 : 85 E2                      			LD		EA, INTAVC		; load vector
 1809/ 8C6 : 74 03                      			BRA		INT1			; skip
 1810/ 8C8 :                            
 1811/ 8C8 : 08                         INTB:		PUSH	EA				; save EA
 1812/ 8C9 : 85 E4                      			LD		EA, INTBVC		; load vector
 1813/ 8CB : 8D E0                      INT1:		ST		EA, INTVEC		; save vector
 1814/ 8CD : 58                         			OR		A, E			; check if EA=0
 1815/ 8CE : 6C 02                      			BZ		INT2			; yes ignore
 1816/ 8D0 : 3A                         			POP		EA				; restore EA
 1817/ 8D1 : 5C                         			RET						; exit
 1818/ 8D2 : 3A                         INT2:		POP		EA				; restore EA
 1819/ 8D3 : 3B 01                      			OR		S, =0x01		; enable interrupts
 1820/ 8D5 : 5C                         			RET						; exit
 1821/ 8D6 :                            
 1822/ 8D6 :                            ;--------------------------------------------------------------------------------------------------
 1823/ 8D6 :                            ; emit error, code is in byte following CALL 15
 1824/ 8D6 : 3A                         ERROR:		POP		EA				; get address of caller
 1825/ 8D7 : 47                         			LD		P3, EA			; into P3
 1826/ 8D8 : 56                         			PUSH	P2    			; save P2
 1827/ 8D9 : 26 15 09                   			LD		P2, =ERRMSG		; address of error message
 1828/ 8DC : 1E                         			CALL 	14				; PRTLN
 1829/ 8DD : 85 EA                      			LD		EA, ZERO		; clear EA
 1830/ 8DF : C3 01                      			LD		A, 1, P3    	; get error number from code
 1831/ 8E1 : 47                         			LD		P3, EA			; into P3
 1832/ 8E2 : 85 C8                      			LD 		EA, AESTK		; get AESTK    
 1833/ 8E4 : 4F                         			XCH		EA, P3			; put into P3, EA is error code
 1834/ 8E5 : 14                         			CALL	4				; APUSH
 1835/ 8E6 : 20 04 05                   			JSR		PRNUM			; print number
 1836/ 8E9 : C5 C2                      			LD		A, INPMOD		; get input mode
 1837/ 8EB : 6C 07                      			BZ		ERRO1			; was in interactive mode, skip
 1838/ 8ED : E4 03                      			XOR		A, =03    		; was 0x03?
 1839/ 8EF : 6C 0C                      			BZ 		ERRO2			; yes, skip
 1840/ 8F1 : 20 0A 09                   			JSR		PRTAT			; otherwise: print AT line#
 1841/ 8F4 : 18                         ERRO1:		CALL 	8				; CRLF
 1842/ 8F5 : 5E                         			POP		P2				; restore P2
 1843/ 8F6 : C4 00                      			LD		A, =0			; set interactive mode
 1844/ 8F8 : CD C2                      			ST		A, INPMOD
 1845/ 8FA : 24 A2 00                   			JMP		MAINLP    		; back to main loop
 1846/ 8FD : 18                         ERRO2:		CALL	8				; CRLF
 1847/ 8FE : 22 21 09                   			PLI		P2, =RETMSG		; load retype msg
 1848/ 901 : 1E                         			CALL 	14				; PRTLN
 1849/ 902 : 5E                         			POP		P2				; restore P2
 1850/ 903 : 18                         			CALL	8				; CRLF
 1851/ 904 : 5E                         			POP		P2    			; restore P2 from call
 1852/ 905 : 85 F2                      			LD		EA, TMPF2		; restore buffer ptr from input save location
 1853/ 907 : 46                         			LD		P2, EA			;
 1854/ 908 : 24 D9 03                   			JMP		INPUT1			; back into INPUT
 1855/ 90B :                            
 1856/ 90B :                            ;--------------------------------------------------------------------------------------------------
 1857/ 90B :                            ; print "AT line#"
 1858/ 90B : 26 1F 09                   PRTAT:		LD		P2, =ATMSG		; at msg
 1859/ 90E : 1E                         			CALL 	14				; PRTLN
 1860/ 90F : 85 C3                      			LD		EA, CURRNT		; current line
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 32 - 2024年05月30日 15時32分15秒


 1861/ 911 : 14                         			CALL	4				; APUSH
 1862/ 912 : 24 04 05                   			JMP		PRNUM    		; print line number
 1863/ 915 :                            
 1864/ 915 : 45 52 52 4F D2             ERRMSG:		DB		'ERRO', 'R'+0x80
 1865/ 91A :                            ;;;STOPMSG:	DB		'STO', 'P'+0x80  BUG???
 1866/ 91A : 53 54 4F 50 A0             STOPMSG:	DB		'STOP', ' '+0x80
 1867/ 91F : 41 D4                      ATMSG:		DB		'A', 'T'+0x80
 1868/ 921 : 52 45 54 59 50 C5          RETMSG:		DB		'RETYP', 'E'+0x80
 1869/ 927 :                            
 1870/ 927 :                            ;--------------------------------------------------------------------------------------------------
 1871/ 927 :                            ; check BREAK from serial, return to mainloop if pressed
 1872/ 927 :                            ; requires BRKFLG=0
 1873/ 927 : C5 E6                      CHKBRK:		LD		A, BRKFLG		; get break flag
 1874/ 929 : 7C 05                      			BNZ		CHKBR1			; if 1 then not enabled
 1875/ 92B : 06                         			LD		A, S			; get status
 1876/ 92C : D4 10                      			AND		A, =0x10		; check SA
 1877/ 92E : 6C 01                      			BZ		CHKBR2			; if low, return to main loop
 1878/ 930 : 5C                         CHKBR1:		RET						; otherwise exit
 1879/ 931 : 24 A2 00                   CHKBR2:		JMP		MAINLP
 1880/ 934 :                            
 1881/ 934 :                            ;--------------------------------------------------------------------------------------------------
 1882/ 934 :                            ; wait for and read a character from input line, return it in A
 1883/ 934 : 22 00 FD                   GECO:		PLI 	P2, =BAUDFLG	; get baudrate flags
 1884/ 937 : C2 00                      			LD 		A, 0, P2		; read bits, here: bit 7
 1885/ 939 : 64 43                      			BP		EXGET			; bit 7=0: call external routine
 1886/ 93B : 5E                         			POP		P2				; restore P2
 1887/ 93C : 06                         			LD		A, S			; get status
 1888/ 93D : 0A                         			PUSH	A				; save it
 1889/ 93E : 39 FE                      			AND		S, =0xfe		; disable IE
 1890/ 940 : C4 09                      			LD		A, =9
 1891/ 942 : CD FF                      			ST		A, TMPFE+1		; store counter for bits
 1892/ 944 : 3B 04                      			OR		S, =0x04		; set F2
 1893/ 946 : 06                         GECO1:		LD		A, S			; read status
 1894/ 947 : D4 10                      			AND		A, =0x10		; select bit SA
 1895/ 949 : 7C FB                      			BNZ		GECO1			; if 1 loop (no start bit)
 1896/ 94B : 20 DF 09                   			JSR		DELAYI			; delay a half bit
 1897/ 94E : 06                         			LD		A, S			; sample status
 1898/ 94F : D4 10                      			AND		A, =0x10		; select bit SA
 1899/ 951 : 7C F3                      			BNZ		GECO1			; still 1, no start bit yet, loop
 1900/ 953 : 39 FB                      			AND		S, =0xfb		; clear F2
 1901/ 955 : 3B 02                      			OR		S, =0x02   		; set F1 (echo bit inverted)
 1902/ 957 : 20 E7 09                   GECO2:		JSR		DELAYI2			; do a full bit delay
 1903/ 95A : 00                         			NOP						; wast some time
 1904/ 95B : 00                         			NOP
 1905/ 95C : 9D FF                      			DLD		A, TMPFE+1		; decrement bit count
 1906/ 95E : 6C 15                      			BZ		GECO3			; if done, exit
 1907/ 960 : 06                         			LD		A, S			; get status
 1908/ 961 : D4 10                      			AND		A, =0x10    	; select bit SA
 1909/ 963 : 3C                         			SR		A				; put bit into position 02 (for F1)
 1910/ 964 : 3C                         			SR		A
 1911/ 965 : 3C                         			SR		A
 1912/ 966 : CD F6                      			ST		A, TMPF6		; store into temporary 
 1913/ 968 : 3C                         			SR		A				; put bit into position 01
 1914/ 969 : 3F                         			RRL		A				; rotate into LINK
 1915/ 96A : 01                         			XCH		A, E  			; collect bit into E
 1916/ 96B : 3D                         			SRL		A				; by rotating LINK into E
 1917/ 96C : 01                         			XCH		A, E
 1918/ 96D : 06                         			LD		A, S			; get status
 1919/ 96E : DC 02                      			OR		A, =0x02		; preload bit 2 with 1
 1920/ 970 : E5 F6                      			XOR		A, TMPF6		; map in bit for F1 echo
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 33 - 2024年05月30日 15時32分15秒


 1921/ 972 : 07                         			LD		S, A			; put out bit
 1922/ 973 : 74 E2                      			BRA		GECO2			; loop
 1923/ 975 : 38                         GECO3:		POP		A				; restore old status
 1924/ 976 : D4 F9                      			AND		A, =0xf9		; clear F1, F2 (stop bits, reader relay)
 1925/ 978 : 07                         			LD		S, A			; emit bits
 1926/ 979 : 40                         			LD		A, E			; get byte received
 1927/ 97A : D4 7F                      			AND		A, =0x7f		; 7 bits only
 1928/ 97C : 48                         			LD		E, A			; save into E
 1929/ 97D : 5C                         			RET						; exit
 1930/ 97E :                            
 1931/ 97E :                            ;--------------------------------------------------------------------------------------------------
 1932/ 97E :                            ; use external GET routine
 1933/ 97E :                            EXGET:
 1934/ 97E : 02                         			DB		2				; getchar(Areg) undefined instruction (I/O Hook)
 1935/ 97F : 5E                         			POP		P2				; restore P2
 1936/ 980 : 5C                         			RET						; exit
 1937/ 981 :                            
 1938/ 981 : 00                         			NOP
 1939/ 982 : 00                         			NOP
 1940/ 983 :                            
 1941/ 983 :                            
 1942/ 983 : 84 07 0A                   ORG_EXGET:	LD		EA, =(EXGET1-1)	; push return to caller on stack
 1943/ 986 : 08                         			PUSH	EA
 1944/ 987 : 82 01                      			LD		EA, 1, P2		; get address of routine 0xFD01
 1945/ 989 : BD E8                      			SUB		EA, ONE   		; subtract 1
 1946/ 98B : 44                         			LD		PC, EA			; jump indirect into routine
 1947/ 98C :                            
 1948/ 98C :                            ;--------------------------------------------------------------------------------------------------
 1949/ 98C :                            ; emit a CRLF (call 8)
 1950/ 98C : C4 0D                      CRLF:		LD		A, =CR			; load CR
 1951/ 98E : 17                         			CALL	7				; PUTC
 1952/ 98F : C4 0A                      			LD		A, =LF			; load LF
 1953/ 991 :                            									; fall thru into PUTC
 1954/ 991 :                            ;--------------------------------------------------------------------------------------------------
 1955/ 991 :                            ; emit the character in A (call 7)						
 1956/ 991 :                            PUTC:
 1957/ 991 : 03                         			DB		3				; putchar(Areg) undefined instruction (I/O Hook)
 1958/ 992 : 5C                         			RET
 1959/ 993 :                            
 1960/ 993 : 00                         			NOP
 1961/ 994 : 00                         			NOP
 1962/ 995 :                            
 1963/ 995 :                            ORG_PUTC:
 1964/ 995 : 0A                         			PUSH 	A				; save A
 1965/ 996 : 22 00 FD                   			PLI 	P2, =BAUDFLG	; push P2 and load baud rate bits
 1966/ 999 : C2 00                      			LD		A, 0, P2		; get baud rate flag, here: bit 7
 1967/ 99B : 64 32                      			BP		EXPUTC   		; bit 7=0: goto external routines
 1968/ 99D : 5E                         			POP		P2				; restore P2
 1969/ 99E : 38                         			POP		A  		  		; restore char
 1970/ 99F : 0A                         			PUSH	A				; save it again
 1971/ 9A0 : 0E                         			SL 		A  		  		; shift left (7 bit), so low bit is in pos 2
 1972/ 9A1 :                            									; note: 8th bit is ignored, and first bit to emit is now
 1973/ 9A1 :                            									; in the correct position for flag F1
 1974/ 9A1 : 01                         			XCH		A, E    		; save current bits in E
 1975/ 9A2 : 06                         			LD		A, S			; get status
 1976/ 9A3 : 0A                         			PUSH	A				; save old state
 1977/ 9A4 : 39 FA                      			AND		S, =0xfa		; clear F2, IE
 1978/ 9A6 : 20 E5 09                   			JSR		DELAYO			; do some delay (ensure two stop bits)
 1979/ 9A9 : 20 E5 09                   			JSR 	DELAYO			;
 1980/ 9AC : 3B 02                      			OR		S, =0x02		; set F1 (start bit)
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 34 - 2024年05月30日 15時32分15秒


 1981/ 9AE :                            									; note inverse logic: start bit is 1
 1982/ 9AE : C4 09                      			LD		A, =9			; set counter for 9 bits
 1983/ 9B0 : CD FB                      			ST		A, TMPFB		
 1984/ 9B2 : 20 E5 09                   PUTC1:		JSR		DELAYO			; wait a bit time
 1985/ 9B5 : 9D FB                      			DLD		A, TMPFB		; decrement bit count
 1986/ 9B7 : 6C 10                      			BZ		PUTC2			; is it zero?, yes skip
 1987/ 9B9 : 40                         			LD		A, E    		; get byte to emit
 1988/ 9BA : D4 02                      			AND		A, =0x02		; extract bit to transfer
 1989/ 9BC : CD FF                      			ST		A, TMPFE+1		; save bit temporary
 1990/ 9BE : 40                         			LD		A, E			; get byte to emit
 1991/ 9BF : 3C                         			SR		A    			; advance to next bit
 1992/ 9C0 : 48                         			LD		E, A			; store back
 1993/ 9C1 : 06                         			LD		A, S			; get status
 1994/ 9C2 : DC 02                      			OR		A, =0x02    	; preload bit 2
 1995/ 9C4 : E5 FF                      			XOR		A, TMPFE+1		; map in inverted data bit
 1996/ 9C6 : 07                         			LD		S, A    		; put out bit at F1
 1997/ 9C7 : 74 E9                      			BRA		PUTC1			; loop bits
 1998/ 9C9 : 38                         PUTC2:		POP		A				; restore saved status
 1999/ 9CA : D4 F9                      			AND		A, =0xf9		; clear F2, F1 (stop bit)
 2000/ 9CC : 07                         			LD		S, A			; put out stop bit
 2001/ 9CD : 38                         			POP		A				; restore char to emit
 2002/ 9CE : 5C                         			RET						; exit
 2003/ 9CF :                            ;--------------------------------------------------------------------------------------------------
 2004/ 9CF :                            ; call external routine for PUTC
 2005/ 9CF : 82 03                      EXPUTC:		LD		EA, 3, P2		; get address at 0xFD03
 2006/ 9D1 : 46                         			LD		P2, EA    		; into P2
 2007/ 9D2 : 84 D9 09                   			LD		EA, =(EXPUT1-1)	; address of return 
 2008/ 9D5 : 08                         			PUSH	EA 				; save on stack (will be called on return)
 2009/ 9D6 : C1 04                      			LD		A, 4, SP		; get char to emit from stack
 2010/ 9D8 : 76 FF                      			BRA		-1, P2			; jump to external routine on stack
 2011/ 9DA : 5E                         EXPUT1:		POP		P2    			; restore original P2
 2012/ 9DB : 38                         			POP A					; restore char to emit
 2013/ 9DC : 5C                         			RET						; return to caller
 2014/ 9DD :                            
 2015/ 9DD :                            ;--------------------------------------------------------------------------------------------------
 2016/ 9DD :                            ; some delay
 2017/ 9DD : 08                         DELAYC:		PUSH	EA				; save EA
 2018/ 9DE : 74 0B                      			BRA		DELAY1			; skip into delay routine
 2019/ 9E0 :                            
 2020/ 9E0 :                            ;--------------------------------------------------------------------------------------------------
 2021/ 9E0 :                            ; (half) delay for input
 2022/ 9E0 : 08                         DELAYI:		PUSH	EA				; save EA
 2023/ 9E1 : 85 EC                      			LD		EA, DLYTIM		; get delay time
 2024/ 9E3 : 0C                         			SR		EA				; div /2
 2025/ 9E4 : 74 05                      			BRA		DELAY1			; skip into delay rountine
 2026/ 9E6 :                            ;--------------------------------------------------------------------------------------------------
 2027/ 9E6 :                            ; delay for output
 2028/ 9E6 : 01                         DELAYO:		XCH		A, E			; waste some time
 2029/ 9E7 : 01                         			XCH		A, E    		; waste some time
 2030/ 9E8 : 08                         DELAYI2:	PUSH	EA				; save EA
 2031/ 9E9 : 85 EC                      			LD		EA, DLYTIM		; get delay constant
 2032/ 9EB : BD E8                      DELAY1:		SUB		EA, ONE			; subtract 1
 2033/ 9ED : 7C FC                      			BNZ		DELAY1			; loop until xx00
 2034/ 9EF : 01                         			XCH		A, E			; is also 00xx?
 2035/ 9F0 : 6C 03                      			BZ		DELAY2			; yes exit
 2036/ 9F2 : 01                         			XCH		A, E			; put back high byte
 2037/ 9F3 : 74 F6                      			BRA		DELAY1 			; loop
 2038/ 9F5 : 3A                         DELAY2:		POP		EA				; restore EA
 2039/ 9F6 : 5C                         			RET						; exit
 2040/ 9F7 :                            
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 35 - 2024年05月30日 15時32分15秒


 2041/ 9F7 :                            ;--------------------------------------------------------------------------------------------------
 2042/ 9F7 :                            	; initialize the variable for baud rate
 2043/ 9F7 : 22 00 FD                   INITBD:		PLI 	P2, =BAUDFLG	; push P2 and load it with baudrate address
 2044/ 9FA : 85 EA                      			LD		EA, ZERO		; clear EA
 2045/ 9FC : C2 00                      			LD		A, 0, P2		; get baud flags
 2046/ 9FE : D4 06                      			AND		A, =0x06    	; mask out bits 1/2
 2047/ A00 : B4 0A 0A                   			ADD		EA, =DLYTAB		; add base of DLY constants
 2048/ A03 : 46                         			LD		P2, EA   		; into P2
 2049/ A04 : 82 00                      			LD		EA, 0, P2		; get constant
 2050/ A06 : 8D EC                      			ST		EA, DLYTIM    	; store it in DLY constant word
 2051/ A08 : 5E                         EXGET1:		POP		P2				; restore P2
 2052/ A09 : 5C                         			RET						; exit
 2053/ A0A : 04 00                      DLYTAB:		DW		0x0004			; delay for 4800bd
 2054/ A0C : 2E 00                      			DW		0x002e			; for 1200 bd
 2055/ A0E : D5 00                      			DW		0x00d5 		; for 300 bd
 2056/ A10 : 52 02                      			DW		0x0252			; for 110 bd
 2057/ A12 :                            			END
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 36 - 2024年05月30日 15時32分15秒


  Symbol Table (* = unused):
  --------------------------

 AESTK :                       FFC8 - |  APULL :                        853 C |
 APUSH :                        843 C |  APUSH1 :                       84E C |
*ARCHITECTURE :                                      "x86_64-unknown-linux" - |
 ARGONE :                       7AC C |  ARGTWO :                       7B5 C |
*ASSIG1 :                       482 C |  ASSIGN :                       464 C |
*ATLH :                         473 C |  ATMSG :                        91F C |
*ATRH :                         73A C |  BAUDFLG :                     FD00 - |
 BMOVE :                        166 C |  BMOVE1 :                       176 C |
 BRKFLG :                      FFE6 - |  BS :                             8 - |
 BUFAD :                       FFD0 - |  CARET :                        '^' - |
*CASESENSITIVE :                  0 - |  CHAR :                         8AC C |
 CHKBR1 :                       930 C |  CHKBR2 :                       931 C |
 CHKBRK :                       927 C |  CHKSBR :                       3CA C |
*CLEAR :                        2DD C |  CMDT10 :                       32C C |
 CMDT11 :                       6AD C |  CMDT12 :                       6FF C |
 CMDT13 :                       6D6 C |  CMDTB1 :                       1A1 C |
 CMDTB2 :                       237 C |  CMDTB4 :                       45A C |
 CMDTB5 :                       26B C |  CMDTB6 :                       1D4 C |
 CMDTB7 :                       2C8 C |  CMDTB8 :                       42C C |
 CMDTB9 :                       326 C |  CMPTO1 :                       61E C |
 CMPTO2 :                       625 C |  CMPTO3 :                       62A C |
 CMPTO4 :                       638 C |  CMPTO5 :                       63F C |
 CMPTOK :                       61D C |  COLD :                           A C |
 COLD1 :                          D C |  COLD2 :                         13 C |
 COLD3 :                         40 C |  COLD4 :                         48 C |
 COLD5 :                         5D C |  COLD6 :                         68 C |
 COMPA1 :                       68F C |  COMPA2 :                       695 C |
 COMPAR :                       683 C | *CONSTPI :        3.141592653589793 - |
*CONT :                         1DA C |  CONTP :                       FFEE - |
 CR :                             D - |  CRLF :                         98C C |
 CTRLH :                        89C C |  CTRLU :                        893 C |
 CURRNT :                      FFC3 - |  CVTHE1 :                       7FB C |
 CVTHEX :                       7F4 C |
*DATE :             "2024\-027\-071\-07605\-026\-100\-12030\-026\-105\-091" - |
*DECFN :                        75C C |  DECFN1 :                       763 C |
 DECFN2 :                       764 C | *DELAY :                        44C C |
 DELAY1 :                       9EB C |  DELAY2 :                       9F5 C |
 DELAYC :                       9DD C |  DELAYI :                       9E0 C |
 DELAYI2 :                      9E8 C |  DELAYO :                       9E6 C |
 DELCH :                        8A2 C | *DIRECT :                       15A C |
 DIVOP :                        816 C |  DLYTAB :                       A0A C |
 DLYTIM :                      FFEC - | *DO :                           2F6 C |
 DO1 :                          307 C |  DOLAL1 :                       4A3 C |
 DOLAL2 :                       4B3 C |  DOLAL3 :                       4BA C |
*DOLAL4 :                       4C1 C |  DOLAL5 :                       4C4 C |
 DOLAL6 :                       4CC C | *DOLALH :                       494 C |
 DOPTR :                       FFDA - |  DOSTK :                       FFCC - |
 DV0ERR :                       826 C |  ENDCM1 :                       21A C |
*ENDCM2 :                       226 C |  ENDCM3 :                       22E C |
 ENDCMD :                       20C C |  ENDRAM1 :                       73 C |
 EOLN :                         8B8 C |  EQERR :                        4CF C |
 ERRMSG :                       915 C |  ERRO1 :                        8F4 C |
 ERRO2 :                        8FD C |  ERROR :                        8D6 C |
 EXEC1 :                        206 C | *EXEC2 :                        25D C |
*EXEC3 :                        2D9 C |  EXGET :                        97E C |
 EXGET1 :                       A08 C |  EXPECT :                       567 C |
 EXPUT1 :                       9DA C |  EXPUTC :                       9CF C |
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 37 - 2024年05月30日 15時32分15秒


 EXTRAM :                      FFC6 - | *FACTO1 :                       6FA C |
*FACTO2 :                       6FB C | *FACTO3 :                       723 C |
 FACTOR :                       6F8 C | *FALSE :                          0 - |
 FINDL1 :                       17A C |  FINDL2 :                       18B C |
 FINDL3 :                       190 C | *FINDL4 :                       197 C |
 FINDLN :                       177 C | *FOR :                          330 C |
*FOR1 :                         33C C | *FOR2 :                         341 C |
*FOR3 :                         344 C |  FOR4 :                         348 C |
 FOR5 :                         36E C |  FORPTR :                      FFDC - |
 FORSTK :                      FFCE - |  GECO :                         934 C |
 GECO1 :                        946 C |  GECO2 :                        957 C |
 GECO3 :                        975 C |  GETCH :                        86B C |
 GETCHR :                       556 C |  GETLN :                        856 C |
 GETLN1 :                       868 C |  GETLN2 :                       86A C |
 GETNXC :                       554 C |  GETSG1 :                       834 C |
 GETSG2 :                       841 C |  GETSGN :                       828 C |
 GETVA1 :                       582 C |  GETVA2 :                       58F C |
 GETVA3 :                       597 C |  GETVA4 :                       599 C |
 GETVAR :                       576 C | *GOCMD :                        267 C |
*GOSUB :                        27F C |  GOSUB1 :                       280 C |
*GOTO :                         273 C |  GOTO1 :                        274 C |
 GTR :                          '>' - | *HAS64 :                          1 - |
 HASHF0 :                       7C3 C |  HASHF1 :                       7CE C |
 HASHF2 :                       7D5 C |  HASHF3 :                       7DB C |
 HASHF4 :                       7E6 C |  HASHF5 :                       7E8 C |
*HASHFN :                       76A C | *IFCMD :                        2B1 C |
*INCFN :                        753 C |  INITA1 :                       5CF C |
 INITA2 :                       609 C |  INITAL :                       5CA C |
 INITBD :                       9F7 C |  INPMOD :                      FFC2 - |
*INPUT :                        447 C |  INPUT0 :                       3D3 C |
 INPUT1 :                       3DA C |  INPUT2 :                       3E6 C |
*INPUT3 :                       406 C |  INPUT4 :                       415 C |
*INPUT5 :                       423 C |  INT1 :                         8CB C |
 INT2 :                         8D2 C |  INTA :                         8C3 C |
 INTAVC :                      FFE2 - |  INTB :                         8C8 C |
 INTBVC :                      FFE4 - |  INTVEC :                      FFE0 - |
*LET :                          261 C |  LF :                             A - |
*LINK :                         2BA C | *LIST :                         1B9 C |
*LIST0 :                        1BD C |  LIST1 :                        1C0 C |
 LIST2 :                        1C3 C | *LIST3 :                        1D0 C |
*LISTON :                         1 - | *LPAREN :                       733 C |
*MACEXP :                         7 - |  MAIN :                          9A C |
 MAIN1 :                        1D1 C | *MAINL1 :                        C1 C |
 MAINL2 :                        C2 C |  MAINL3 :                        E1 C |
 MAINL4 :                       104 C |  MAINL5 :                       140 C |
 MAINL6 :                       150 C |  MAINL7 :                       157 C |
 MAINLP :                        A3 C |  MDTER0 :                       6D2 C |
*MDTER1 :                       6DF C |  MDTER2 :                       6E4 C |
*MDTER3 :                       6E7 C | *MDTER4 :                       6EE C |
 MDTERM :                       6D1 C | *MODFN :                        76C C |
 MODFN1 :                       770 C | *MOMCPU :                      8070 - |
*MOMCPUNAME :                "8070" - |  MULOV :                       FFC0 - |
 MULTO1 :                       806 C |  MULTOP :                       7FE C |
*NAK :                           15 - |  NEGAT1 :                       814 C |
 NEGATE :                       80B C | *NESTMAX :                      100 - |
 NEW :                           8C C | *NEW2 :                         1B4 C |
*NEXT :                         264 C |  NEXT0 :                        372 C |
 NEXT1 :                        378 C |  NEXT2 :                        38F C |
 NEXT3 :                        39C C |  NEXT4 :                        39F C |
 NEXT5 :                        3A1 C |  NOINT :                       FFE7 - |
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 38 - 2024年05月30日 15時32分15秒


*NOTFN :                        740 C |  NSERR :                        3CF C |
*NUMBE1 :                       5A6 C |  NUMBE11 :                      5A7 C |
 NUMBE2 :                       5BD C |  NUMBE3 :                       5C2 C |
 NUMBE4 :                       5C4 C |  NUMBER :                       59E C |
 NXADD :                        3AF C |  NXADD1 :                       3C1 C |
 NXADD2 :                       3C4 C |  NXERR :                        370 C |
 OMERR :                        164 C | *ON :                           2E1 C |
*ON1 :                          2E5 C |  ON2 :                          2F1 C |
 ONE :                         FFE8 - |  OPTBL1 :                       64C C |
*ORG_EXGET :                    983 C | *ORG_PUTC :                     995 C |
 PEEK :                         72C C | *PRINT :                        449 C |
 PRINT0 :                       4D3 C |  PRINT1 :                       4DB C |
 PRINT2 :                       4EA C | *PRINT3 :                       4F5 C |
 PRINT4 :                       4F9 C | *PRINT5 :                       4FF C |
*PRINT6 :                       503 C |  PRNUM :                        505 C |
 PRNUM1 :                       513 C |  PRNUM2 :                       516 C |
 PRNUM3 :                       51E C |  PRNUM4 :                       53A C |
 PRTAT :                        90B C |  PRTLN :                        548 C |
 PRTLN1 :                       553 C |  PUTC :                         991 C |
 PUTC1 :                        9B2 C |  PUTC2 :                        9C9 C |
 QUEST :                        '?' - |  RAMBASE :                     1000 - |
*RELAXED :                        0 - | *RELEQ :                        65C C |
 RELEX1 :                       678 C |  RELEX2 :                       67F C |
*RELEX3 :                       682 C |  RELEXP :                       645 C |
*RELGE :                        670 C | *RELGT :                        675 C |
*RELLE :                        661 C | *RELLT :                        66B C |
*RELNE :                        666 C |  REMCMD :                       2AB C |
 RETERR :                       2A7 C |  RETMSG :                       921 C |
*RETURN :                       295 C | *RNDFN :                        787 C |
 RNDNUM :                      FFF4 - |  ROMBASE :                     1400 - |
 RUN :                          1E3 C |  RUN1 :                         1EF C |
 RUN2 :                         1F3 C | *RUN3 :                         1F6 C |
 RUN4 :                         201 C |  RUNMOD :                      FFC5 - |
 SAVOP :                        850 C |  SBRPTR :                      FFDE - |
 SBRSTK :                      FFCA - | *SNERR :                        4D1 C |
*SNERR1 :                       20A C | *SNERR2 :                       3AD C |
*SNERR3 :                       738 C | *SNERR4 :                       7C1 C |
 SPACE :                        ' ' - |  STACK :                       FFD2 - |
*STATLH :                       468 C | *STATRH :                       74A C |
*STOP :                         457 C |  STOPMSG :                      91A C |
 SUERR :                        3D1 C |  SWPBUF :                       424 C |
 TERM :                         698 C |  TERM1 :                        6A0 C |
*TERM2 :                        6A3 C | *TERM3 :                        6A6 C |
 TERM4 :                        6A9 C | *TERM5 :                        6B5 C |
*TERM6 :                        6BD C | *TERM7 :                        6C5 C |
*TIME :               "15\-026\-103\-12632\-027\-120\-12215\-025\-089\-110" - |
 TMPF0 :                       FFF0 - |  TMPF2 :                       FFF2 - |
 TMPF6 :                       FFF6 - |  TMPFB :                       FFFB - |
 TMPFC :                       FFFC - |  TMPFE :                       FFFE - |
 TOEOLN :                       19B C | *TOPFN :                        74D C |
*TRUE :                           1 - | *TSTRAM :                        7C C |
 TSTRAM1 :                       76 C |  TXTBGN :                      FFD4 - |
 TXTEND :                      FFD8 - |  TXTUNF :                      FFD6 - |
 UCERR :                        1B7 C | *UNTIL :                        2A9 C |
 UNTIL0 :                       30A C |  UNTIL1 :                       314 C |
 UNTIL2 :                       31F C | *UNUSE1 :                      FFF8 - |
*VERSION :                     142F - |  ZERO :                        FFEA - |

    344 symbols
     97 unused symbols
 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 39 - 2024年05月30日 15時32分15秒



 AS V1.42 Beta [Bld 269] - Source File nibl3.asm - Page 40 - 2024年05月30日 15時32分15秒


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.01 seconds assembly time

   2059 lines source file
      2 passes
      0 errors
      0 warnings
